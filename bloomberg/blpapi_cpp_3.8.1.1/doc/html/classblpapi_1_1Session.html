<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BLPAPI C++: Class blpapi::Session</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>


  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="components.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceblpapi.html">blpapi</a>      </li>
      <li><a class="el" href="classblpapi_1_1Session.html">blpapi::Session</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>blpapi::Session Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="blpapi::Session" --><!-- doxytag: inherits="blpapi::AbstractSession" -->
<p><code>#include &lt;<a class="el" href="blpapi__session_8h_source.html">blpapi_session.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for blpapi::Session:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classblpapi_1_1Session.png" usemap="#blpapi::Session_map" alt=""/>
  <map id="blpapi::Session_map" name="blpapi::Session_map">
<area href="classblpapi_1_1AbstractSession.html" alt="blpapi::AbstractSession" shape="rect" coords="0,0,143,24"/>
</map>
</div>

<p><a href="classblpapi_1_1Session-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360">SubscriptionStatus</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360a410f8e81450850ae6cecd92da3f18dec">UNSUBSCRIBED</a> =  BLPAPI_SUBSCRIPTIONSTATUS_UNSUBSCRIBED, 
<a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360a38b26d48c50b472f66893a93edf4c15f">SUBSCRIBING</a> =  BLPAPI_SUBSCRIPTIONSTATUS_SUBSCRIBING, 
<a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360ac238df3a8ab8e98950aa4dc0a8f35b6b">SUBSCRIBED</a> =  BLPAPI_SUBSCRIPTIONSTATUS_SUBSCRIBED, 
<a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360a0abd1365c5cae7e3acdc713addce9cb5">CANCELLED</a> =  BLPAPI_SUBSCRIPTIONSTATUS_CANCELLED, 
<br/>
&nbsp;&nbsp;<a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360ab9d2fc78ba78271e982a3171e90b156a">PENDING_CANCELLATION</a> =  BLPAPI_SUBSCRIPTIONSTATUS_PENDING_CANCELLATION
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#ad311ac8efcc76c198eb8d4300b344a67">Session</a> (const <a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a> &amp;options=<a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a>(), <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> *eventHandler=0, <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> *eventDispatcher=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a0d9bebc2fd146fc72bf9e6cc1c57025a">Session</a> (<a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a2386b4275f4f342f4081736ec1599af9">~Session</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#adf5890d97c42d723a05324442e5dfbd2">start</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">startAsync</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a6f56c2d6bb2a8db31f3f988f94094375">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a3acd2cd31ed28ebc16493e3e3858c724">stopAsync</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1Event.html">Event</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent</a> (int timeout=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a8e3d03c818e237df36c1e80cdbdefef4">tryNextEvent</a> (<a class="el" href="classblpapi_1_1Event.html">Event</a> *event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a789706bf48e914d3589305b888f8b6b1">subscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptionList, const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;identity, const char *requestLabel=0, int requestLabelLen=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#ada0074be4af0f622b9eecb0f24cc2a65">subscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptionList, const char *requestLabel=0, int requestLabelLen=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#acf4106693af831d34ef8975c4a9bc085">unsubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptionList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#af63802b60053a5cf0d3537c1fff8003a">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a1a01e7dd6dc7dbe5e9d1cdecbdc095d2">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions, const char *requestLabel, int requestLabelLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a3cf20abf037df1eae1865c6662cd6d43">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions, int resubscriptionId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#abaafbf911b29abefe1105b85415113e0">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions, int resubscriptionId, const char *requestLabel, int requestLabelLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#ac12f339ee05ecfcae7f59d77bbb472ec">setStatusCorrelationId</a> (const <a class="el" href="classblpapi_1_1Service.html">Service</a> &amp;service, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a805c0b9358b72a9ea275646b98100130">setStatusCorrelationId</a> (const <a class="el" href="classblpapi_1_1Service.html">Service</a> &amp;service, const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;identity, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#ab805165a1b386bcc3e3a037cac56a9b5">sendRequest</a> (const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;request, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0, const char *requestLabel=0, int requestLabelLen=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#abce276fc31d7ba1cee8cf8a132f4c445">sendRequest</a> (const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;request, const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;user, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0, const char *requestLabel=0, int requestLabelLen=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a12963467436094660d332dcf22a4b655">handle</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a7537ccb4f2ae4d0b0b96c52459c18415">openService</a> (const char *serviceIdentifier)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a27bf5aa507e10b89d4142a52b5492d05">openServiceAsync</a> (const char *serviceIdentifier, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a6f2b9ede1f99ef66e3d68e012f2ccbd3">sendAuthorizationRequest</a> (const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;authorizationRequest, <a class="el" href="classblpapi_1_1Identity.html">Identity</a> *identity, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a5dbf6676a42dacbb64cd8a1d75d8a94c">cancel</a> (const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a6bc1ca990b97df8c2d30a7dc35d78ccd">cancel</a> (const std::vector&lt; <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &gt; &amp;correlationIds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a1038d502cbeb8cf1f5ea3aa7dd774dc6">cancel</a> (const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> *correlationIds, size_t numCorrelationIds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#ace702470c7b7faa2e9c57c8dc33d8b6e">generateToken</a> (const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1Service.html">Service</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a0441e5ed7f56f4cb6ef4a8735aa166c1">getService</a> (const char *serviceIdentifier) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1Identity.html">UserHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#ac5d7a27d3ffff9c218a3e02764ee0a86">createUserHandle</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1Identity.html">Identity</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a94326b82070728bff232866546acd8fa">createIdentity</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#aced40ce5767d5e2d7cb18688a790378e">abstractSessionHandle</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a72fbfd14bd1e06ee4a041385923d20f6">initAbstractSessionHandle</a> (<a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a> *handle)</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#acda0390c96f63b0717628f1249348a57">eventHandlerProxy</a> (<a class="el" href="group__blpapi__types.html#ga30bfd6b43ae20d0c8b1baf6f700450c6">blpapi_Event_t</a> *event, <a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a> *session, void *userData)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides a consumer session for making requests for Bloomberg services.</p>
<p>Sessions manage access to services either by requests and responses or subscriptions. A <a class="el" href="classblpapi_1_1Session.html">Session</a> can dispatch events and replies in either a synchronous or asynchronous mode. The mode of a <a class="el" href="classblpapi_1_1Session.html">Session</a> is determined when it is constructed and cannot be changed subsequently.</p>
<p>A <a class="el" href="classblpapi_1_1Session.html">Session</a> is asynchronous if an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> object is supplied when it is constructed. The setEventHandler() method may be called to adjust the way events are handled subsequently and the <a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent()</a> method may not be called. All incoming events are delivered to the EventHandler(s) supplied on construction or subsequently using setEventHandler().</p>
<p>A <a class="el" href="classblpapi_1_1Session.html">Session</a> is synchronous if an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> object is not supplied when it is constructed. The <a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent()</a> method must be called to read incoming events and the setEventHandler() method may not be called.</p>
<p>Several methods in <a class="el" href="classblpapi_1_1Session.html">Session</a> take a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> parameter. The application may choose to supply its own <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> values or allow the <a class="el" href="classblpapi_1_1Session.html">Session</a> to create values. If the application supplies its own <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> values it must manage their lifetime such that the same value is not reused for more than one operation at a time. The lifetime of a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> begins when it is supplied in a method invoked on a <a class="el" href="classblpapi_1_1Session.html">Session</a> and ends either when it is explicitly cancelled using <a class="el" href="classblpapi_1_1AbstractSession.html#a5dbf6676a42dacbb64cd8a1d75d8a94c">cancel()</a> or <a class="el" href="classblpapi_1_1Session.html#acf4106693af831d34ef8975c4a9bc085">unsubscribe()</a>, when a RESPONSE <a class="el" href="classblpapi_1_1Event.html">Event</a> (not a PARTIAL_RESPONSE) containing it is received or when a SUBSCRIPTION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> which indicates that the subscription it refers to has been terminated is received.</p>
<p>When using an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> the application must be aware that because the callbacks are generated from another thread they may be processed before the call which generates them has returned. For example, the SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> generated by a <a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">startAsync()</a> may be processed before <a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">startAsync()</a> has returned (even though <a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">startAsync()</a> itself will not block).</p>
<p>This becomes more significant when <a class="el" href="classblpapi_1_1Session.html">Session</a> generated CorrelationIds are in use. For example, if a call to <a class="el" href="classblpapi_1_1Session.html#a789706bf48e914d3589305b888f8b6b1">subscribe()</a> which returns a <a class="el" href="classblpapi_1_1Session.html">Session</a> generated <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> has not completed before the first Events which contain that <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> arrive the application may not be able to interpret those events correctly. For this reason, it is preferable to use user generated CorrelationIds when using asynchronous Sessions. This issue does not arise when using a synchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> as long as the calls to <a class="el" href="classblpapi_1_1Session.html#a789706bf48e914d3589305b888f8b6b1">subscribe()</a> etc are made on the same thread as the calls to <a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent()</a>. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360"></a><!-- doxytag: member="blpapi::Session::SubscriptionStatus" ref="a5fe1734809ad256c4c45d5e2ef327360" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360">blpapi::Session::SubscriptionStatus</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360a410f8e81450850ae6cecd92da3f18dec"></a><!-- doxytag: member="UNSUBSCRIBED" ref="a5fe1734809ad256c4c45d5e2ef327360a410f8e81450850ae6cecd92da3f18dec" args="" -->UNSUBSCRIBED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360a38b26d48c50b472f66893a93edf4c15f"></a><!-- doxytag: member="SUBSCRIBING" ref="a5fe1734809ad256c4c45d5e2ef327360a38b26d48c50b472f66893a93edf4c15f" args="" -->SUBSCRIBING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360ac238df3a8ab8e98950aa4dc0a8f35b6b"></a><!-- doxytag: member="SUBSCRIBED" ref="a5fe1734809ad256c4c45d5e2ef327360ac238df3a8ab8e98950aa4dc0a8f35b6b" args="" -->SUBSCRIBED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360a0abd1365c5cae7e3acdc713addce9cb5"></a><!-- doxytag: member="CANCELLED" ref="a5fe1734809ad256c4c45d5e2ef327360a0abd1365c5cae7e3acdc713addce9cb5" args="" -->CANCELLED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360ab9d2fc78ba78271e982a3171e90b156a"></a><!-- doxytag: member="PENDING_CANCELLATION" ref="a5fe1734809ad256c4c45d5e2ef327360ab9d2fc78ba78271e982a3171e90b156a" args="" -->PENDING_CANCELLATION</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad311ac8efcc76c198eb8d4300b344a67"></a><!-- doxytag: member="blpapi::Session::Session" ref="ad311ac8efcc76c198eb8d4300b344a67" args="(const SessionOptions &amp;options=SessionOptions(), EventHandler *eventHandler=0, EventDispatcher *eventDispatcher=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">blpapi::Session::Session </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> *&nbsp;</td>
          <td class="paramname"> <em>eventHandler</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> *&nbsp;</td>
          <td class="paramname"> <em>eventDispatcher</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="classblpapi_1_1Session.html">Session</a> using the optionally specified <code>options</code>, the optionally specified <code>eventHandler</code> and the optionally specified <code>eventDispatcher</code>.</p>
<p>See the <a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a> documentation for details on what can be specified in the <code>options</code>.</p>
<p>If <code>eventHandler</code> is not 0 then this <a class="el" href="classblpapi_1_1Session.html">Session</a> will operation in asynchronous mode, otherwise the <a class="el" href="classblpapi_1_1Session.html">Session</a> will operate in synchronous mode.</p>
<p>If <code>eventDispatcher</code> is 0 then the <a class="el" href="classblpapi_1_1Session.html">Session</a> will create a default <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> for this <a class="el" href="classblpapi_1_1Session.html">Session</a> which will use a single thread for dispatching events. For more control over event dispatching a specific instance of <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> can be supplied. This can be used to share a single <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> amongst multiple <a class="el" href="classblpapi_1_1Session.html">Session</a> objects.</p>
<p>If an <code>eventDispatcher</code> is supplied which uses more than one thread the <a class="el" href="classblpapi_1_1Session.html">Session</a> will ensure that events which should be ordered are passed to callbacks in a correct order. For example, partial response to a request or updates to a single subscription.</p>
<p>If <code>eventHandler</code> is 0 and the <code>eventDispatcher</code> is not 0 an exception is thrown.</p>
<p>Each <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> uses its own thread or pool of threads so if you want to ensure that a session which receives very large messages and takes a long time to process them does not delay a session that receives small messages and processes each one very quickly then give each one a separate <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a>. </p>

</div>
</div>
<a class="anchor" id="a0d9bebc2fd146fc72bf9e6cc1c57025a"></a><!-- doxytag: member="blpapi::Session::Session" ref="a0d9bebc2fd146fc72bf9e6cc1c57025a" args="(blpapi_Session_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">blpapi::Session::Session </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2386b4275f4f342f4081736ec1599af9"></a><!-- doxytag: member="blpapi::Session::~Session" ref="a2386b4275f4f342f4081736ec1599af9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual blpapi::Session::~Session </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adf5890d97c42d723a05324442e5dfbd2"></a><!-- doxytag: member="blpapi::Session::start" ref="adf5890d97c42d723a05324442e5dfbd2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blpapi::Session::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to start this <a class="el" href="classblpapi_1_1Session.html">Session</a> and blocks until the <a class="el" href="classblpapi_1_1Session.html">Session</a> has started or failed to start. If the <a class="el" href="classblpapi_1_1Session.html">Session</a> is started successfully <code>true</code> is returned, otherwise <code>false</code> is returned. Before <a class="el" href="classblpapi_1_1Session.html#adf5890d97c42d723a05324442e5dfbd2">start()</a> returns a SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> is generated. If this is an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> then the SESSION_STATUS may be processed by the registered <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> before <a class="el" href="classblpapi_1_1Session.html#adf5890d97c42d723a05324442e5dfbd2">start()</a> has returned. A <a class="el" href="classblpapi_1_1Session.html">Session</a> may only be started once. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#ace4e657cd0a05ebed423e888f4ce943f">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a0f51151d1f1aecb4e3df1ab9494cb9a4"></a><!-- doxytag: member="blpapi::Session::startAsync" ref="a0f51151d1f1aecb4e3df1ab9494cb9a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blpapi::Session::startAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to begin the process to start this <a class="el" href="classblpapi_1_1Session.html">Session</a> and return <code>true</code> if successful, otherwise return <code>false</code>. The application must monitor events for a SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> which will be generated once the <a class="el" href="classblpapi_1_1Session.html">Session</a> has started or if it fails to start. If this is an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> then the SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> may be processed by the registered <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> before <a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">startAsync()</a> has returned. A <a class="el" href="classblpapi_1_1Session.html">Session</a> may only be started once. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#ab2c59500373e25393dbfe20311361d9d">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a6f56c2d6bb2a8db31f3f988f94094375"></a><!-- doxytag: member="blpapi::Session::stop" ref="a6f56c2d6bb2a8db31f3f988f94094375" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop operation of this session and block until all callbacks to <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> objects relating to this <a class="el" href="classblpapi_1_1Session.html">Session</a> which are currently in progress have completed (including the callback to handle the SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> with SessionTerminated message this call generates). Once this returns no further callbacks to EventHandlers will occur. If <a class="el" href="classblpapi_1_1Session.html#a6f56c2d6bb2a8db31f3f988f94094375">stop()</a> is called from within an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> callback the behavior is undefined and may result in a deadlock. Once a <a class="el" href="classblpapi_1_1Session.html">Session</a> has been stopped it can only be destroyed. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#a969ca873556672770ca09295fe1a5870">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a3acd2cd31ed28ebc16493e3e3858c724"></a><!-- doxytag: member="blpapi::Session::stopAsync" ref="a3acd2cd31ed28ebc16493e3e3858c724" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::stopAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin the process to stop this <a class="el" href="classblpapi_1_1Session.html">Session</a> and return immediately. The application must monitor events for a SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> with SessionTerminated message which will be generated once the <a class="el" href="classblpapi_1_1Session.html">Session</a> has been stopped. After this SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> no further callbacks to EventHandlers will occur. This method can be called from within an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> callback to stop Sessions using non-default (external) <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a>. Once a <a class="el" href="classblpapi_1_1Session.html">Session</a> has been stopped it can only be destroyed. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#af45d8a8baaffaedba84142efead7dccb">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ae4047ea10fb95b189847d5d67d73a027"></a><!-- doxytag: member="blpapi::Session::nextEvent" ref="ae4047ea10fb95b189847d5d67d73a027" args="(int timeout=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1Event.html">Event</a> blpapi::Session::nextEvent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the next available <a class="el" href="classblpapi_1_1Event.html">Event</a> for this session. If there is no event available this will block for up to the specified <code>timeoutMillis</code> milliseconds for an <a class="el" href="classblpapi_1_1Event.html">Event</a> to arrive. A value of 0 for <code>timeoutMillis</code> (the default) indicates <a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent()</a> should not timeout and will not return until the next <a class="el" href="classblpapi_1_1Event.html">Event</a> is available.</p>
<p>If <a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent()</a> returns due to a timeout it will return an event of type <code>EventType::TIMEOUT</code>.</p>
<p>If this is invoked on a <a class="el" href="classblpapi_1_1Session.html">Session</a> which was created in asynchronous mode an <a class="el" href="classblpapi_1_1InvalidStateException.html">InvalidStateException</a> is thrown. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#a6ad5b2d683b4b80b00134bd3d855fbe6">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a8e3d03c818e237df36c1e80cdbdefef4"></a><!-- doxytag: member="blpapi::Session::tryNextEvent" ref="a8e3d03c818e237df36c1e80cdbdefef4" args="(Event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int blpapi::Session::tryNextEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1Event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If there are Events available for the session, load the next <a class="el" href="classblpapi_1_1Event.html">Event</a> into event and return 0 indicating success. If there is no event available for the session, return a non-zero value with no effect on event. This method never blocks. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#af2b18809b8fd26cf3a943a3e433a1bcc">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a789706bf48e914d3589305b888f8b6b1"></a><!-- doxytag: member="blpapi::Session::subscribe" ref="a789706bf48e914d3589305b888f8b6b1" args="(const SubscriptionList &amp;subscriptionList, const Identity &amp;identity, const char *requestLabel=0, int requestLabelLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::Session::subscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin subscriptions for each entry in the specified <code>subscriptionList</code> using the specified <code>identity</code> for authorization. If the optional <code>requestLabel</code> and <code>requestLabelLen</code> are provided they define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>A SUBSCRIPTION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> will be generated for each entry in the <code>subscriptionList</code>. </p>

</div>
</div>
<a class="anchor" id="ada0074be4af0f622b9eecb0f24cc2a65"></a><!-- doxytag: member="blpapi::Session::subscribe" ref="ada0074be4af0f622b9eecb0f24cc2a65" args="(const SubscriptionList &amp;subscriptionList, const char *requestLabel=0, int requestLabelLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::Session::subscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin subscriptions for each entry in the specified <code>subscriptionList</code> using the default authorization information. If the optional <code>requestLabel</code> and <code>requestLabelLen</code> are provided they define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>A SUBSCRIPTION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> will be generated for each entry in the <code>subscriptionList</code>. </p>

</div>
</div>
<a class="anchor" id="acf4106693af831d34ef8975c4a9bc085"></a><!-- doxytag: member="blpapi::Session::unsubscribe" ref="acf4106693af831d34ef8975c4a9bc085" args="(const SubscriptionList &amp;subscriptionList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::Session::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptionList</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel each of the current subscriptions identified by the specified <code>subscriptionList</code>. If the correlation ID of any entry in the <code>subscriptionList</code> does not identify a current subscription then that entry is ignored. All entries which have valid correlation IDs will be cancelled.</p>
<p>Once this call returns the correlation ids in the <code>subscriptionList</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1Session.html#acf4106693af831d34ef8975c4a9bc085">unsubscribe()</a> is called is not affected even if it has one of the correlation IDs in the <code>subscriptionList</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain a correlation ID from the <code>subscriptionList</code>. For these reasons, although technically an application is free to re-use the correlation IDs as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="af63802b60053a5cf0d3537c1fff8003a"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="af63802b60053a5cf0d3537c1fff8003a" args="(const SubscriptionList &amp;subscriptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event will be generated in the event stream before the first update based on the new options. If the correlation ID of an entry in the <code>subscriptionList</code> does not identify a current subscription then an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a1a01e7dd6dc7dbe5e9d1cdecbdc095d2"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="a1a01e7dd6dc7dbe5e9d1cdecbdc095d2" args="(const SubscriptionList &amp;subscriptions, const char *requestLabel, int requestLabelLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it. The specified <code>requestLabel</code> and <code>requestLabelLen</code> define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event will be generated in the event stream before the first update based on the new options. If the correlation ID of an entry in the <code>subscriptionList</code> does not identify a current subscription then an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a3cf20abf037df1eae1865c6662cd6d43"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="a3cf20abf037df1eae1865c6662cd6d43" args="(const SubscriptionList &amp;subscriptions, int resubscriptionId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>resubscriptionId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event containing the specified <code>resubscriptionId</code> will be generated in the event stream before the first update based on the new options. If the correlation ID of an entry in the <code>subscriptionList</code> does not identify a current subscription then an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="abaafbf911b29abefe1105b85415113e0"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="abaafbf911b29abefe1105b85415113e0" args="(const SubscriptionList &amp;subscriptions, int resubscriptionId, const char *requestLabel, int requestLabelLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>resubscriptionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it. The specified <code>requestLabel</code> and <code>requestLabelLen</code> define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event containing the specified <code>resubscriptionId</code> will be generated in the event stream before the first update based on the new options. If the correlation ID of an entry in the <code>subscriptionList</code> does not identify a current subscription then an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ac12f339ee05ecfcae7f59d77bbb472ec"></a><!-- doxytag: member="blpapi::Session::setStatusCorrelationId" ref="ac12f339ee05ecfcae7f59d77bbb472ec" args="(const Service &amp;service, const CorrelationId &amp;correlationID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::Session::setStatusCorrelationId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Service.html">Service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a805c0b9358b72a9ea275646b98100130"></a><!-- doxytag: member="blpapi::Session::setStatusCorrelationId" ref="a805c0b9358b72a9ea275646b98100130" args="(const Service &amp;service, const Identity &amp;identity, const CorrelationId &amp;correlationID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::Session::setStatusCorrelationId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Service.html">Service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the CorrelationID on which service status messages will be received. Note: No service status messages are received prior to this call </p>

</div>
</div>
<a class="anchor" id="ab805165a1b386bcc3e3a037cac56a9b5"></a><!-- doxytag: member="blpapi::Session::sendRequest" ref="ab805165a1b386bcc3e3a037cac56a9b5" args="(const Request &amp;request, const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0, const char *requestLabel=0, int requestLabelLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::Session::sendRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send the specified <code>request</code>. If the optionally specified <code>correlationId</code> is supplied use it otherwise create a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>. The actual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> used is returned. If the optionally specified <code>eventQueue</code> is supplied all events relating to this <a class="el" href="classblpapi_1_1Request.html">Request</a> will arrive on that <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a>. If the optional <code>requestLabel</code> and <code>requestLabelLen</code> are provided they define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>A successful request will generate zero or more PARTIAL_RESPONSE Messages followed by exactly one RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a>. Once the final RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a> has been received the correlation ID associated with this request may be re-used. If the request fails at any stage a REQUEST_STATUS will be generated after which the correlation ID associated with the request may be re-used. </p>

</div>
</div>
<a class="anchor" id="abce276fc31d7ba1cee8cf8a132f4c445"></a><!-- doxytag: member="blpapi::Session::sendRequest" ref="abce276fc31d7ba1cee8cf8a132f4c445" args="(const Request &amp;request, const Identity &amp;user, const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0, const char *requestLabel=0, int requestLabelLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::Session::sendRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send the specified <code>request</code> using the specified <code>identity</code> for authorization. If the optionally specified <code>correlationId</code> is supplied use it otherwise create a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>. The actual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> used is returned. If the optionally specified <code>eventQueue</code> is supplied all events relating to this <a class="el" href="classblpapi_1_1Request.html">Request</a> will arrive on that <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a>. If the optional <code>requestLabel</code> and <code>requestLabelLen</code> are provided they define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>A successful request will generate zero or more PARTIAL_RESPONSE Messages followed by exactly one RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a>. Once the final RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a> has been received the <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> associated with this request may be re-used. If the request fails at any stage a REQUEST_STATUS will be generated after which the <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> associated with the request may be re-used. </p>

</div>
</div>
<a class="anchor" id="a12963467436094660d332dcf22a4b655"></a><!-- doxytag: member="blpapi::Session::handle" ref="a12963467436094660d332dcf22a4b655" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a>* blpapi::Session::handle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a72fbfd14bd1e06ee4a041385923d20f6"></a><!-- doxytag: member="blpapi::Session::initAbstractSessionHandle" ref="a72fbfd14bd1e06ee4a041385923d20f6" args="(blpapi_AbstractSession_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::AbstractSession::initAbstractSessionHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the handle of this abstract session. </p>

</div>
</div>
<a class="anchor" id="a7537ccb4f2ae4d0b0b96c52459c18415"></a><!-- doxytag: member="blpapi::Session::openService" ref="a7537ccb4f2ae4d0b0b96c52459c18415" args="(const char *serviceIdentifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool blpapi::AbstractSession::openService </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>serviceIdentifier</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to open the service identified by the specified <code>serviceIdentifier</code> and block until the service is either opened successfully or has failed to be opened. Return <code>true</code> if the service is opened successfully and <code>false</code> if the service cannot be successfully opened.</p>
<p>The <code>serviceIdentifier</code> must contain a fully qualified service name. That is, it must be of the form "//&lt;namespace&gt;/&lt;local-name&gt;".</p>
<p>Before <a class="el" href="classblpapi_1_1AbstractSession.html#a7537ccb4f2ae4d0b0b96c52459c18415">openService()</a> returns a SERVICE_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> is generated. If this is an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> then this <a class="el" href="classblpapi_1_1Event.html">Event</a> may be processed by the registered <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> before <a class="el" href="classblpapi_1_1AbstractSession.html#a7537ccb4f2ae4d0b0b96c52459c18415">openService()</a> has returned. </p>

</div>
</div>
<a class="anchor" id="a27bf5aa507e10b89d4142a52b5492d05"></a><!-- doxytag: member="blpapi::Session::openServiceAsync" ref="a27bf5aa507e10b89d4142a52b5492d05" args="(const char *serviceIdentifier, const CorrelationId &amp;correlationId=CorrelationId())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::openServiceAsync </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>serviceIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin the process to open the service identified by the specified <code>serviceIdentifier</code> and return immediately. The optional specified <code>correlationId</code> is used to track Events generated as a result of this call. The actual correlationId which will identify Events generated as a result of this call is returned.</p>
<p>The <code>serviceIdentifier</code> must contain a fully qualified service name. That is, it must be of the form "//&lt;namespace&gt;/&lt;local-name&gt;".</p>
<p>The application must monitor events for a SERVICE_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> which will be generated once the service has been successfully opened or the opening has failed. </p>

</div>
</div>
<a class="anchor" id="a6f2b9ede1f99ef66e3d68e012f2ccbd3"></a><!-- doxytag: member="blpapi::Session::sendAuthorizationRequest" ref="a6f2b9ede1f99ef66e3d68e012f2ccbd3" args="(const Request &amp;authorizationRequest, Identity *identity, const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::sendAuthorizationRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>authorizationRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1Identity.html">Identity</a> *&nbsp;</td>
          <td class="paramname"> <em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send the specified <code>authorizationRequest</code> and update the specified <code>identity</code> with the results. If the optionally specified <code>correlationId</code> is supplied, it is used; otherwise create a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>. The actual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> used is returned. If the optionally specified <code>eventQueue</code> is supplied all Events relating to this <a class="el" href="classblpapi_1_1Request.html">Request</a> will arrive on that <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a>.</p>
<p>The underlying user information must remain valid until the <a class="el" href="classblpapi_1_1Request.html">Request</a> has completed successfully or failed.</p>
<p>A successful request will generate zero or more PARTIAL_RESPONSE Messages followed by exactly one RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a>. Once the final RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a> has been received the specified <code>identity</code> will have been updated to contain the users entitlement information and the <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> associated with the request may be re-used. If the request fails at any stage a REQUEST_STATUS will be generated, the specified <code>identity</code> will not be modified and the <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> may be re-used.</p>
<p>The <code>identity</code> supplied must have been returned from this Session's <a class="el" href="classblpapi_1_1AbstractSession.html#a94326b82070728bff232866546acd8fa">createIdentity()</a> method. For example <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">         Identity handle(session.createIdentity());
         session.sendAuthorizationRequest(authRequest, &amp;handle, ...)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a5dbf6676a42dacbb64cd8a1d75d8a94c"></a><!-- doxytag: member="blpapi::Session::cancel" ref="a5dbf6676a42dacbb64cd8a1d75d8a94c" args="(const CorrelationId &amp;correlationId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::AbstractSession::cancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the specified <code>correlationId</code> identifies a current request then cancel that request.</p>
<p>Once this call returns the specified <code>correlationId</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1AbstractSession.html#a5dbf6676a42dacbb64cd8a1d75d8a94c">cancel()</a> is called is not affected even if it has the specified <code>correlationId</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain the <code>correlationId</code>. For these reasons, although technically an application is free to re-use <code>correlationId</code> as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="a6bc1ca990b97df8c2d30a7dc35d78ccd"></a><!-- doxytag: member="blpapi::Session::cancel" ref="a6bc1ca990b97df8c2d30a7dc35d78ccd" args="(const std::vector&lt; CorrelationId &gt; &amp;correlationIds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::AbstractSession::cancel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationIds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each value in the specified <code>correlationIds</code> which identifies a current request then cancel that request. Any values in the specified <code>correlationIds</code> which do not identify a current request are ignored.</p>
<p>Once this call returns the specified <code>correlationIds</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1AbstractSession.html#a5dbf6676a42dacbb64cd8a1d75d8a94c">cancel()</a> is called is not affected even if it has one of the specified <code>correlationIds</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain one of the <code>correlationIds</code>. For these reasons, although technically an application is free to re-use any of the <code>correlationIds</code> as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="a1038d502cbeb8cf1f5ea3aa7dd774dc6"></a><!-- doxytag: member="blpapi::Session::cancel" ref="a1038d502cbeb8cf1f5ea3aa7dd774dc6" args="(const CorrelationId *correlationIds, size_t numCorrelationIds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::AbstractSession::cancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> *&nbsp;</td>
          <td class="paramname"> <em>correlationIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numCorrelationIds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each value specified <code>correlationIds</code> and <code>numCorrelationIds</code> which identifies a current request then cancel that request. Any specified CorrelationId's which do not identify a current request are ignored.</p>
<p>Once this call returns the specified <code>correlationIds</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1AbstractSession.html#a5dbf6676a42dacbb64cd8a1d75d8a94c">cancel()</a> is called is not affected even if it has one of the specified <code>correlationIds</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain one of the <code>correlationIds</code>. For these reasons, although technically an application is free to re-use any of the <code>correlationIds</code> as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="ace702470c7b7faa2e9c57c8dc33d8b6e"></a><!-- doxytag: member="blpapi::Session::generateToken" ref="ace702470c7b7faa2e9c57c8dc33d8b6e" args="(const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::generateToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a token to be used for authorization. If invalid authentication option is specified in session option or there is failure to get authentication information based on authentication option, then an <a class="el" href="classblpapi_1_1InvalidArgumentException.html">InvalidArgumentException</a> is thrown. </p>

</div>
</div>
<a class="anchor" id="a0441e5ed7f56f4cb6ef4a8735aa166c1"></a><!-- doxytag: member="blpapi::Session::getService" ref="a0441e5ed7f56f4cb6ef4a8735aa166c1" args="(const char *serviceIdentifier) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1Service.html">Service</a> blpapi::AbstractSession::getService </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>serviceIdentifier</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <a class="el" href="classblpapi_1_1Service.html">Service</a> object representing the service identified by the specified <code>serviceIdentifier</code></p>
<p>The <code>serviceIdentifier</code> must contain a fully qualified service name. That is, it must be of the form "//&lt;namespace&gt;/&lt;local-name&gt;".</p>
<p>If the service identified by <code>serviceIdentifier</code> is not open or registered already then a <code><a class="el" href="classblpapi_1_1NotFoundException.html">NotFoundException</a></code> is thrown. </p>

</div>
</div>
<a class="anchor" id="ac5d7a27d3ffff9c218a3e02764ee0a86"></a><!-- doxytag: member="blpapi::Session::createUserHandle" ref="ac5d7a27d3ffff9c218a3e02764ee0a86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1Identity.html">UserHandle</a> blpapi::AbstractSession::createUserHandle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deprecated: Use <a class="el" href="classblpapi_1_1AbstractSession.html#a94326b82070728bff232866546acd8fa">createIdentity()</a> instead. TODO: doxy Return a UserHandle which is valid but has not been authorized. </p>

</div>
</div>
<a class="anchor" id="a94326b82070728bff232866546acd8fa"></a><!-- doxytag: member="blpapi::Session::createIdentity" ref="a94326b82070728bff232866546acd8fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1Identity.html">Identity</a> blpapi::AbstractSession::createIdentity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <a class="el" href="classblpapi_1_1Identity.html">Identity</a> which is valid but has not been authorized. </p>

</div>
</div>
<a class="anchor" id="aced40ce5767d5e2d7cb18688a790378e"></a><!-- doxytag: member="blpapi::Session::abstractSessionHandle" ref="aced40ce5767d5e2d7cb18688a790378e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a>* blpapi::AbstractSession::abstractSessionHandle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the handle of this abstract session. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="acda0390c96f63b0717628f1249348a57"></a><!-- doxytag: member="blpapi::Session::eventHandlerProxy" ref="acda0390c96f63b0717628f1249348a57" args="(blpapi_Event_t *event, blpapi_Session_t *session, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eventHandlerProxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__blpapi__types.html#ga30bfd6b43ae20d0c8b1baf6f700450c6">blpapi_Event_t</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="blpapi__session_8h_source.html">blpapi_session.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 18 2014 11:05:53 for BLPAPI 3.8.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
