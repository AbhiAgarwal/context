<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BLPAPI C++: Class blpapi::AbstractSession</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>


  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="components.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceblpapi.html">blpapi</a>      </li>
      <li><a class="el" href="classblpapi_1_1AbstractSession.html">blpapi::AbstractSession</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>blpapi::AbstractSession Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="blpapi::AbstractSession" -->
<p><code>#include &lt;<a class="el" href="blpapi__abstractsession_8h_source.html">blpapi_abstractsession.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for blpapi::AbstractSession:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classblpapi_1_1AbstractSession.png" usemap="#blpapi::AbstractSession_map" alt=""/>
  <map id="blpapi::AbstractSession_map" name="blpapi::AbstractSession_map">
<area href="classblpapi_1_1ProviderSession.html" alt="blpapi::ProviderSession" shape="rect" coords="0,56,145,80"/>
<area href="classblpapi_1_1Session.html" alt="blpapi::Session" shape="rect" coords="155,56,300,80"/>
</map>
</div>

<p><a href="classblpapi_1_1AbstractSession-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a672fc76a817f98dd0c8d09ca11e10e88">~AbstractSession</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#ace4e657cd0a05ebed423e888f4ce943f">start</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#ab2c59500373e25393dbfe20311361d9d">startAsync</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a969ca873556672770ca09295fe1a5870">stop</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#af45d8a8baaffaedba84142efead7dccb">stopAsync</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1Event.html">Event</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a6ad5b2d683b4b80b00134bd3d855fbe6">nextEvent</a> (int timeout=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#af2b18809b8fd26cf3a943a3e433a1bcc">tryNextEvent</a> (<a class="el" href="classblpapi_1_1Event.html">Event</a> *event)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a7537ccb4f2ae4d0b0b96c52459c18415">openService</a> (const char *serviceIdentifier)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a27bf5aa507e10b89d4142a52b5492d05">openServiceAsync</a> (const char *serviceIdentifier, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a6f2b9ede1f99ef66e3d68e012f2ccbd3">sendAuthorizationRequest</a> (const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;authorizationRequest, <a class="el" href="classblpapi_1_1Identity.html">Identity</a> *identity, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a5dbf6676a42dacbb64cd8a1d75d8a94c">cancel</a> (const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a6bc1ca990b97df8c2d30a7dc35d78ccd">cancel</a> (const std::vector&lt; <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &gt; &amp;correlationIds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a1038d502cbeb8cf1f5ea3aa7dd774dc6">cancel</a> (const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> *correlationIds, size_t numCorrelationIds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#ace702470c7b7faa2e9c57c8dc33d8b6e">generateToken</a> (const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1Service.html">Service</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a0441e5ed7f56f4cb6ef4a8735aa166c1">getService</a> (const char *serviceIdentifier) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1Identity.html">UserHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#ac5d7a27d3ffff9c218a3e02764ee0a86">createUserHandle</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1Identity.html">Identity</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a94326b82070728bff232866546acd8fa">createIdentity</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#aced40ce5767d5e2d7cb18688a790378e">abstractSessionHandle</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a844db9434d9f526655e4030486722623">AbstractSession</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a72fbfd14bd1e06ee4a041385923d20f6">initAbstractSessionHandle</a> (<a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a> *handle)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides an abstract session which defines shared interface between publish and consumer requests for Bloomberg</p>
<p>Sessions manage access to services either by requests and responses or subscriptions. A <a class="el" href="classblpapi_1_1Session.html">Session</a> can dispatch events and replies in either a synchronous or asynchronous mode. The mode of a <a class="el" href="classblpapi_1_1Session.html">Session</a> is determined when it is constructed and cannot be changed subsequently.</p>
<p>A <a class="el" href="classblpapi_1_1Session.html">Session</a> is asynchronous if an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> object is supplied when it is constructed. The setEventHandler() method may be called to adjust the way events are handled subsequently and the <a class="el" href="classblpapi_1_1AbstractSession.html#a6ad5b2d683b4b80b00134bd3d855fbe6">nextEvent()</a> method may not be called. All incoming events are delivered to the EventHandler(s) supplied on construction or subsequently using setEventHandler().</p>
<p>A <a class="el" href="classblpapi_1_1Session.html">Session</a> is synchronous if an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> object is not supplied when it is constructed. The <a class="el" href="classblpapi_1_1AbstractSession.html#a6ad5b2d683b4b80b00134bd3d855fbe6">nextEvent()</a> method must be called to read incoming events and the setEventHandler() method may not be called.</p>
<p>Several methods in <a class="el" href="classblpapi_1_1Session.html">Session</a> take a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> parameter. The application may choose to supply its own <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> values or allow the <a class="el" href="classblpapi_1_1Session.html">Session</a> to create values. If the application supplies its own <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> values it must manage their lifetime such that the same value is not reused for more than one operation at a time. The lifetime of a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> begins when it is supplied in a method invoked on a <a class="el" href="classblpapi_1_1Session.html">Session</a> and ends either when it is explicitly cancelled using <a class="el" href="classblpapi_1_1AbstractSession.html#a5dbf6676a42dacbb64cd8a1d75d8a94c">cancel()</a> or unsubscribe(), when a RESPONSE <a class="el" href="classblpapi_1_1Event.html">Event</a> (not a PARTIAL_RESPONSE) containing it is received or when a SUBSCRIPTION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> which indicates that the subscription it refers to has been terminated is received.</p>
<p>When using an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> the application must be aware that because the callbacks are generated from another thread they may be processed before the call which generates them has returned. For example, the SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> generated by a <a class="el" href="classblpapi_1_1AbstractSession.html#ab2c59500373e25393dbfe20311361d9d">startAsync()</a> may be processed before <a class="el" href="classblpapi_1_1AbstractSession.html#ab2c59500373e25393dbfe20311361d9d">startAsync()</a> has returned (even though <a class="el" href="classblpapi_1_1AbstractSession.html#ab2c59500373e25393dbfe20311361d9d">startAsync()</a> itself will not block).</p>
<p>This becomes more significant when <a class="el" href="classblpapi_1_1Session.html">Session</a> generated CorrelationIds are in use. For example, if a call to subscribe() which returns a <a class="el" href="classblpapi_1_1Session.html">Session</a> generated <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> has not completed before the first Events which contain that <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> arrive the application may not be able to interpret those events correctly. For this reason, it is preferable to use user generated CorrelationIds when using asynchronous Sessions. This issue does not arise when using a synchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> as long as the calls to subscribe() etc are made on the same thread as the calls to <a class="el" href="classblpapi_1_1AbstractSession.html#a6ad5b2d683b4b80b00134bd3d855fbe6">nextEvent()</a>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a844db9434d9f526655e4030486722623"></a><!-- doxytag: member="blpapi::AbstractSession::AbstractSession" ref="a844db9434d9f526655e4030486722623" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">blpapi::AbstractSession::AbstractSession </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an abstract session object. </p>

</div>
</div>
<a class="anchor" id="a672fc76a817f98dd0c8d09ca11e10e88"></a><!-- doxytag: member="blpapi::AbstractSession::~AbstractSession" ref="a672fc76a817f98dd0c8d09ca11e10e88" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual blpapi::AbstractSession::~AbstractSession </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a72fbfd14bd1e06ee4a041385923d20f6"></a><!-- doxytag: member="blpapi::AbstractSession::initAbstractSessionHandle" ref="a72fbfd14bd1e06ee4a041385923d20f6" args="(blpapi_AbstractSession_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::AbstractSession::initAbstractSessionHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the handle of this abstract session. </p>

</div>
</div>
<a class="anchor" id="ace4e657cd0a05ebed423e888f4ce943f"></a><!-- doxytag: member="blpapi::AbstractSession::start" ref="ace4e657cd0a05ebed423e888f4ce943f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blpapi::AbstractSession::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to start this <a class="el" href="classblpapi_1_1Session.html">Session</a> and blocks until the <a class="el" href="classblpapi_1_1Session.html">Session</a> has started or failed to start. If the <a class="el" href="classblpapi_1_1Session.html">Session</a> is started successfully <code>true</code> is returned, otherwise <code>false</code> is returned. Before <a class="el" href="classblpapi_1_1AbstractSession.html#ace4e657cd0a05ebed423e888f4ce943f">start()</a> returns a SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> is generated. If this is an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> then the SESSION_STATUS may be processed by the registered <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> before <a class="el" href="classblpapi_1_1AbstractSession.html#ace4e657cd0a05ebed423e888f4ce943f">start()</a> has returned. A <a class="el" href="classblpapi_1_1Session.html">Session</a> may only be started once. </p>

<p>Implemented in <a class="el" href="classblpapi_1_1ProviderSession.html#a7c54e715203b0377d22c37ee7b919e53">blpapi::ProviderSession</a>, and <a class="el" href="classblpapi_1_1Session.html#adf5890d97c42d723a05324442e5dfbd2">blpapi::Session</a>.</p>

</div>
</div>
<a class="anchor" id="ab2c59500373e25393dbfe20311361d9d"></a><!-- doxytag: member="blpapi::AbstractSession::startAsync" ref="ab2c59500373e25393dbfe20311361d9d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blpapi::AbstractSession::startAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to begin the process to start this <a class="el" href="classblpapi_1_1Session.html">Session</a> and return <code>true</code> if successful, otherwise return <code>false</code>. The application must monitor events for a SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> which will be generated once the <a class="el" href="classblpapi_1_1Session.html">Session</a> has started or if it fails to start. If this is an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> then the SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> may be processed by the registered <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> before <a class="el" href="classblpapi_1_1AbstractSession.html#ab2c59500373e25393dbfe20311361d9d">startAsync()</a> has returned. A <a class="el" href="classblpapi_1_1Session.html">Session</a> may only be started once. </p>

<p>Implemented in <a class="el" href="classblpapi_1_1ProviderSession.html#afd9700ea81e63f88cd345c9169b9b54e">blpapi::ProviderSession</a>, and <a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">blpapi::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a969ca873556672770ca09295fe1a5870"></a><!-- doxytag: member="blpapi::AbstractSession::stop" ref="a969ca873556672770ca09295fe1a5870" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::AbstractSession::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop operation of this session and block until all callbacks to <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> objects relating to this <a class="el" href="classblpapi_1_1Session.html">Session</a> which are currently in progress have completed (including the callback to handle the SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> with SessionTerminated message this call generates). Once this returns no further callbacks to EventHandlers will occur. If <a class="el" href="classblpapi_1_1AbstractSession.html#a969ca873556672770ca09295fe1a5870">stop()</a> is called from within an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> callback the behavior is undefined and may result in a deadlock. Once a <a class="el" href="classblpapi_1_1Session.html">Session</a> has been stopped it can only be destroyed. </p>

<p>Implemented in <a class="el" href="classblpapi_1_1ProviderSession.html#a9916b2b6d99c2299919c6f459887661a">blpapi::ProviderSession</a>, and <a class="el" href="classblpapi_1_1Session.html#a6f56c2d6bb2a8db31f3f988f94094375">blpapi::Session</a>.</p>

</div>
</div>
<a class="anchor" id="af45d8a8baaffaedba84142efead7dccb"></a><!-- doxytag: member="blpapi::AbstractSession::stopAsync" ref="af45d8a8baaffaedba84142efead7dccb" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::AbstractSession::stopAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin the process to stop this <a class="el" href="classblpapi_1_1Session.html">Session</a> and return immediately. The application must monitor events for a SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> with SessionTerminated message which will be generated once the <a class="el" href="classblpapi_1_1Session.html">Session</a> has been stopped. After this SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> no further callbacks to EventHandlers will occur. This method can be called from within an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> callback to stop Sessions using non-default (external) <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a>. Once a <a class="el" href="classblpapi_1_1Session.html">Session</a> has been stopped it can only be destroyed. </p>

<p>Implemented in <a class="el" href="classblpapi_1_1ProviderSession.html#ade6d8ccab9e8debae283c1cca9f40ead">blpapi::ProviderSession</a>, and <a class="el" href="classblpapi_1_1Session.html#a3acd2cd31ed28ebc16493e3e3858c724">blpapi::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a6ad5b2d683b4b80b00134bd3d855fbe6"></a><!-- doxytag: member="blpapi::AbstractSession::nextEvent" ref="a6ad5b2d683b4b80b00134bd3d855fbe6" args="(int timeout=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1Event.html">Event</a> blpapi::AbstractSession::nextEvent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the next available <a class="el" href="classblpapi_1_1Event.html">Event</a> for this session. If there is no event available this will block for up to the specified <code>timeoutMillis</code> milliseconds for an <a class="el" href="classblpapi_1_1Event.html">Event</a> to arrive. A value of 0 for <code>timeoutMillis</code> (the default) indicates <a class="el" href="classblpapi_1_1AbstractSession.html#a6ad5b2d683b4b80b00134bd3d855fbe6">nextEvent()</a> should not timeout and will not return until the next <a class="el" href="classblpapi_1_1Event.html">Event</a> is available.</p>
<p>If <a class="el" href="classblpapi_1_1AbstractSession.html#a6ad5b2d683b4b80b00134bd3d855fbe6">nextEvent()</a> returns due to a timeout it will return an event of type <code>EventType::TIMEOUT</code>.</p>
<p>If this is invoked on a <a class="el" href="classblpapi_1_1Session.html">Session</a> which was created in asynchronous mode an <a class="el" href="classblpapi_1_1InvalidStateException.html">InvalidStateException</a> is thrown. </p>

<p>Implemented in <a class="el" href="classblpapi_1_1ProviderSession.html#a98ccf42cad3ac4ac66a7291c1001b5a7">blpapi::ProviderSession</a>, and <a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">blpapi::Session</a>.</p>

</div>
</div>
<a class="anchor" id="af2b18809b8fd26cf3a943a3e433a1bcc"></a><!-- doxytag: member="blpapi::AbstractSession::tryNextEvent" ref="af2b18809b8fd26cf3a943a3e433a1bcc" args="(Event *event)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int blpapi::AbstractSession::tryNextEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1Event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If there are Events available for the session, load the next <a class="el" href="classblpapi_1_1Event.html">Event</a> into event and return 0 indicating success. If there is no event available for the session, return a non-zero value with no effect on event. This method never blocks. </p>

<p>Implemented in <a class="el" href="classblpapi_1_1ProviderSession.html#a56ad4a4e532f686e537925e6ba436b28">blpapi::ProviderSession</a>, and <a class="el" href="classblpapi_1_1Session.html#a8e3d03c818e237df36c1e80cdbdefef4">blpapi::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a7537ccb4f2ae4d0b0b96c52459c18415"></a><!-- doxytag: member="blpapi::AbstractSession::openService" ref="a7537ccb4f2ae4d0b0b96c52459c18415" args="(const char *serviceIdentifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool blpapi::AbstractSession::openService </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>serviceIdentifier</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to open the service identified by the specified <code>serviceIdentifier</code> and block until the service is either opened successfully or has failed to be opened. Return <code>true</code> if the service is opened successfully and <code>false</code> if the service cannot be successfully opened.</p>
<p>The <code>serviceIdentifier</code> must contain a fully qualified service name. That is, it must be of the form "//&lt;namespace&gt;/&lt;local-name&gt;".</p>
<p>Before <a class="el" href="classblpapi_1_1AbstractSession.html#a7537ccb4f2ae4d0b0b96c52459c18415">openService()</a> returns a SERVICE_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> is generated. If this is an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> then this <a class="el" href="classblpapi_1_1Event.html">Event</a> may be processed by the registered <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> before <a class="el" href="classblpapi_1_1AbstractSession.html#a7537ccb4f2ae4d0b0b96c52459c18415">openService()</a> has returned. </p>

</div>
</div>
<a class="anchor" id="a27bf5aa507e10b89d4142a52b5492d05"></a><!-- doxytag: member="blpapi::AbstractSession::openServiceAsync" ref="a27bf5aa507e10b89d4142a52b5492d05" args="(const char *serviceIdentifier, const CorrelationId &amp;correlationId=CorrelationId())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::openServiceAsync </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>serviceIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin the process to open the service identified by the specified <code>serviceIdentifier</code> and return immediately. The optional specified <code>correlationId</code> is used to track Events generated as a result of this call. The actual correlationId which will identify Events generated as a result of this call is returned.</p>
<p>The <code>serviceIdentifier</code> must contain a fully qualified service name. That is, it must be of the form "//&lt;namespace&gt;/&lt;local-name&gt;".</p>
<p>The application must monitor events for a SERVICE_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> which will be generated once the service has been successfully opened or the opening has failed. </p>

</div>
</div>
<a class="anchor" id="a6f2b9ede1f99ef66e3d68e012f2ccbd3"></a><!-- doxytag: member="blpapi::AbstractSession::sendAuthorizationRequest" ref="a6f2b9ede1f99ef66e3d68e012f2ccbd3" args="(const Request &amp;authorizationRequest, Identity *identity, const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::sendAuthorizationRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>authorizationRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1Identity.html">Identity</a> *&nbsp;</td>
          <td class="paramname"> <em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send the specified <code>authorizationRequest</code> and update the specified <code>identity</code> with the results. If the optionally specified <code>correlationId</code> is supplied, it is used; otherwise create a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>. The actual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> used is returned. If the optionally specified <code>eventQueue</code> is supplied all Events relating to this <a class="el" href="classblpapi_1_1Request.html">Request</a> will arrive on that <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a>.</p>
<p>The underlying user information must remain valid until the <a class="el" href="classblpapi_1_1Request.html">Request</a> has completed successfully or failed.</p>
<p>A successful request will generate zero or more PARTIAL_RESPONSE Messages followed by exactly one RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a>. Once the final RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a> has been received the specified <code>identity</code> will have been updated to contain the users entitlement information and the <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> associated with the request may be re-used. If the request fails at any stage a REQUEST_STATUS will be generated, the specified <code>identity</code> will not be modified and the <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> may be re-used.</p>
<p>The <code>identity</code> supplied must have been returned from this Session's <a class="el" href="classblpapi_1_1AbstractSession.html#a94326b82070728bff232866546acd8fa">createIdentity()</a> method. For example <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">         Identity handle(session.createIdentity());
         session.sendAuthorizationRequest(authRequest, &amp;handle, ...)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a5dbf6676a42dacbb64cd8a1d75d8a94c"></a><!-- doxytag: member="blpapi::AbstractSession::cancel" ref="a5dbf6676a42dacbb64cd8a1d75d8a94c" args="(const CorrelationId &amp;correlationId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::AbstractSession::cancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the specified <code>correlationId</code> identifies a current request then cancel that request.</p>
<p>Once this call returns the specified <code>correlationId</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1AbstractSession.html#a5dbf6676a42dacbb64cd8a1d75d8a94c">cancel()</a> is called is not affected even if it has the specified <code>correlationId</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain the <code>correlationId</code>. For these reasons, although technically an application is free to re-use <code>correlationId</code> as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="a6bc1ca990b97df8c2d30a7dc35d78ccd"></a><!-- doxytag: member="blpapi::AbstractSession::cancel" ref="a6bc1ca990b97df8c2d30a7dc35d78ccd" args="(const std::vector&lt; CorrelationId &gt; &amp;correlationIds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::AbstractSession::cancel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationIds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each value in the specified <code>correlationIds</code> which identifies a current request then cancel that request. Any values in the specified <code>correlationIds</code> which do not identify a current request are ignored.</p>
<p>Once this call returns the specified <code>correlationIds</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1AbstractSession.html#a5dbf6676a42dacbb64cd8a1d75d8a94c">cancel()</a> is called is not affected even if it has one of the specified <code>correlationIds</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain one of the <code>correlationIds</code>. For these reasons, although technically an application is free to re-use any of the <code>correlationIds</code> as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="a1038d502cbeb8cf1f5ea3aa7dd774dc6"></a><!-- doxytag: member="blpapi::AbstractSession::cancel" ref="a1038d502cbeb8cf1f5ea3aa7dd774dc6" args="(const CorrelationId *correlationIds, size_t numCorrelationIds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::AbstractSession::cancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> *&nbsp;</td>
          <td class="paramname"> <em>correlationIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numCorrelationIds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each value specified <code>correlationIds</code> and <code>numCorrelationIds</code> which identifies a current request then cancel that request. Any specified CorrelationId's which do not identify a current request are ignored.</p>
<p>Once this call returns the specified <code>correlationIds</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1AbstractSession.html#a5dbf6676a42dacbb64cd8a1d75d8a94c">cancel()</a> is called is not affected even if it has one of the specified <code>correlationIds</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain one of the <code>correlationIds</code>. For these reasons, although technically an application is free to re-use any of the <code>correlationIds</code> as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="ace702470c7b7faa2e9c57c8dc33d8b6e"></a><!-- doxytag: member="blpapi::AbstractSession::generateToken" ref="ace702470c7b7faa2e9c57c8dc33d8b6e" args="(const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::generateToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a token to be used for authorization. If invalid authentication option is specified in session option or there is failure to get authentication information based on authentication option, then an <a class="el" href="classblpapi_1_1InvalidArgumentException.html">InvalidArgumentException</a> is thrown. </p>

</div>
</div>
<a class="anchor" id="a0441e5ed7f56f4cb6ef4a8735aa166c1"></a><!-- doxytag: member="blpapi::AbstractSession::getService" ref="a0441e5ed7f56f4cb6ef4a8735aa166c1" args="(const char *serviceIdentifier) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1Service.html">Service</a> blpapi::AbstractSession::getService </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>serviceIdentifier</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <a class="el" href="classblpapi_1_1Service.html">Service</a> object representing the service identified by the specified <code>serviceIdentifier</code></p>
<p>The <code>serviceIdentifier</code> must contain a fully qualified service name. That is, it must be of the form "//&lt;namespace&gt;/&lt;local-name&gt;".</p>
<p>If the service identified by <code>serviceIdentifier</code> is not open or registered already then a <code><a class="el" href="classblpapi_1_1NotFoundException.html">NotFoundException</a></code> is thrown. </p>

</div>
</div>
<a class="anchor" id="ac5d7a27d3ffff9c218a3e02764ee0a86"></a><!-- doxytag: member="blpapi::AbstractSession::createUserHandle" ref="ac5d7a27d3ffff9c218a3e02764ee0a86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1Identity.html">UserHandle</a> blpapi::AbstractSession::createUserHandle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deprecated: Use <a class="el" href="classblpapi_1_1AbstractSession.html#a94326b82070728bff232866546acd8fa">createIdentity()</a> instead. TODO: doxy Return a UserHandle which is valid but has not been authorized. </p>

</div>
</div>
<a class="anchor" id="a94326b82070728bff232866546acd8fa"></a><!-- doxytag: member="blpapi::AbstractSession::createIdentity" ref="a94326b82070728bff232866546acd8fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1Identity.html">Identity</a> blpapi::AbstractSession::createIdentity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <a class="el" href="classblpapi_1_1Identity.html">Identity</a> which is valid but has not been authorized. </p>

</div>
</div>
<a class="anchor" id="aced40ce5767d5e2d7cb18688a790378e"></a><!-- doxytag: member="blpapi::AbstractSession::abstractSessionHandle" ref="aced40ce5767d5e2d7cb18688a790378e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a>* blpapi::AbstractSession::abstractSessionHandle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the handle of this abstract session. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="blpapi__abstractsession_8h_source.html">blpapi_abstractsession.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 18 2014 11:05:52 for BLPAPI 3.8.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
