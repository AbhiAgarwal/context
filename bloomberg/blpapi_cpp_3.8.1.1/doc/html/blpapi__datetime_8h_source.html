<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BLPAPI C++</title>
<html>
<pre>
/* Copyright 2012. Bloomberg Finance L.P.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:  The above
 * copyright notice and this permission notice shall be included in all copies
 * or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
// blpapi_datetime.h                                                  -*-C++-*-
#ifndef INCLUDED_BLPAPI_DATETIME
#define INCLUDED_BLPAPI_DATETIME
//@PURPOSE: Represents a date and/or time.
//
//@CLASSES:
//                blpapi_Datetime_tag: C struct for date and/or msec time
//   blpapi_HighPrecisionDatetime_tag: C struct for date and/or psec time
//                   blpapi::Datetime: C++ class for date and/or psec time
//              blpapi::DatetimeParts: Identifiers for fields within date/time
//               blpapi::DatetimeUtil: &#39;Datetime&#39; utility functions 
//
//@DESCRIPTION: This file provides a C and C++ data type to represent a
// date and/or time value.

#ifndef INCLUDED_BLPAPI_CALL
#include &lt;blpapi_call.h&gt;
#endif

#ifndef INCLUDED_BLPAPI_DEFS
#include &lt;blpapi_defs.h&gt;
#endif

#ifndef INCLUDED_BLPAPI_EXCEPTION
#include &lt;blpapi_exception.h&gt;
#endif

#ifndef INCLUDED_BLPAPI_STREAMPROXY
#include &lt;blpapi_streamproxy.h&gt;
#endif

#ifndef INCLUDED_BLPAPI_TIMEPOINT
#include &lt;blpapi_timepoint.h&gt;
#endif

#ifndef INCLUDED_BLPAPI_TYPES
#include &lt;blpapi_types.h&gt;
#endif

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

struct blpapi_Datetime_tag {
    blpapi_UChar_t  parts;        // bitmask of date/time parts that are set
    blpapi_UChar_t  hours;
    blpapi_UChar_t  minutes;
    blpapi_UChar_t  seconds;
    blpapi_UInt16_t milliSeconds;
    blpapi_UChar_t  month;
    blpapi_UChar_t  day;
    blpapi_UInt16_t year;
    blpapi_Int16_t  offset;       // (signed) minutes ahead of UTC
};

typedef struct blpapi_Datetime_tag blpapi_Datetime_t;

struct blpapi_HighPrecisionDatetime_tag {
    blpapi_Datetime_t datetime;
    blpapi_UInt32_t picoseconds; // picosecond offset into current
                                 // *millisecond* i.e. the picosecond offset
                                 // into the current full second is
                                 // &#39;1000000000LL * milliSeconds + picoSeconds&#39;
};

typedef struct blpapi_HighPrecisionDatetime_tag blpapi_HighPrecisionDatetime_t;

BLPAPI_EXPORT
int blpapi_Datetime_compare(blpapi_Datetime_t lhs, blpapi_Datetime_t rhs);


BLPAPI_EXPORT
int blpapi_Datetime_print(const blpapi_Datetime_t *datetime,
                          blpapi_StreamWriter_t streamWriter,
                          void *stream,
                          int level,
                          int spacesPerLevel);

BLPAPI_EXPORT
int blpapi_HighPrecisionDatetime_compare(
                                    const blpapi_HighPrecisionDatetime_t *lhs,
                                    const blpapi_HighPrecisionDatetime_t *rhs);


BLPAPI_EXPORT
int blpapi_HighPrecisionDatetime_print(
                         const blpapi_HighPrecisionDatetime_t *datetime,
                         blpapi_StreamWriter_t                 streamWriter,
                         void                                 *stream,
                         int                                   level,
                         int                                   spacesPerLevel);

BLPAPI_EXPORT
int blpapi_HighPrecisionDatetime_fromTimePoint(
                                     blpapi_HighPrecisionDatetime_t *datetime,
                                     const blpapi_TimePoint_t       *timePoint,
                                     short                           offset);

#ifdef __cplusplus
} // extern &quot;C&quot;

#ifndef INCLUDED_CASSERT
#include &lt;cassert&gt;
#define INCLUDED_CASSERT
#endif

#ifndef INCLUDED_CSTRING
#include &lt;cstring&gt; // for std::memset
#define INCLUDED_CSTRING
#endif

#ifndef INCLUDED_IOSFWD
#include &lt;iosfwd&gt;
#define INCLUDED_IOSFWD
#endif

namespace BloombergLP {
namespace blpapi {

                            // ====================
                            // struct DatetimeParts
                            // ====================

struct DatetimeParts {
    // Bit flags and masks used to determine which parts of a Datetime are
    // valid.

    enum Value {
        // Enumeration used to indicate which parts of the &#39;Datetime&#39; object
        // have had their values set.  The actual enumeration constants are
        // thus *not* consecutive -- they are bit fields that can be combined
        // using bitwise operators.  Note that the constants themselves are
        // defined in &#39;blpapi_defs.h&#39;.

          YEAR            = BLPAPI_DATETIME_YEAR_PART            // year is set
        , MONTH           = BLPAPI_DATETIME_MONTH_PART           // month is set
        , DAY             = BLPAPI_DATETIME_DAY_PART             // day is set
        , OFFSET          = BLPAPI_DATETIME_OFFSET_PART          // offset is set
        , HOURS           = BLPAPI_DATETIME_HOURS_PART           // hours is set
        , MINUTES         = BLPAPI_DATETIME_MINUTES_PART         // minutes is set
        , SECONDS         = BLPAPI_DATETIME_SECONDS_PART         // seconds is set
        , FRACSECONDS     = BLPAPI_DATETIME_FRACSECONDS_PART     // fraction-of-second (both millisecond and picosecond) is set
        , MILLISECONDS    = BLPAPI_DATETIME_MILLISECONDS_PART    // &#39;MILLISECONDS&#39; is a (legacy) synonym for &#39;FRACSECONDS&#39;
        , DATE            = BLPAPI_DATETIME_DATE_PART            // year, month, and day are set
        , TIME            = BLPAPI_DATETIME_TIME_PART            // hours, minutes, and seconds are set
        , TIMEFRACSECONDS = BLPAPI_DATETIME_TIMEFRACSECONDS_PART // hours, minutes, seconds, and fraction-of-second are set
        , TIMEMILLI       = BLPAPI_DATETIME_TIMEMILLI_PART       // &#39;TIMEMILLI&#39; is a (legacy) synonym for &#39;TIMEFRACSECONDS&#39;
    };
};

                               // ==============
                               // class Datetime
                               // ==============

class Datetime {
    // Represents a date and/or time.
    //
    // Datetime can represent a date and/or a time or any combination of the
    // components of a date and time.  The value is represented as eight parts
    // which can be set or queried independently.
    //
    // These parts are: year; month (from January as 1 to December as 12); day
    // (of month, from 1 to 31); hour (from 0 to 23); minute (0 to 59); second
    // (0 to 59); fraction-of-second (logically representing arbitrary
    // precision, with the current interface providing picosecond resolution);
    // and offset (time zone as minutes ahead of UTC).
    //
    // Methods are provided to set and query the parts individually and in
    // groups, e.g. &#39;setDate()&#39; and &#39;setTime()&#39;.  It is also possible to
    // determine which parts of the &#39;Datetime&#39; have been set (via the &#39;parts()&#39;
    // method).

    blpapi_HighPrecisionDatetime_t d_value;

    static bool isLeapYear(int year);

    struct TimeTag {};
    Datetime(unsigned hours,
             unsigned minutes,
             unsigned seconds,
             TimeTag);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39;.  The
        // behavior is undefined unless &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39;
        // represent a valid time as specified by the &#39;isValidTime&#39; function.
        // The resulting &#39;Datetime&#39; object has the parts specified by &#39;TIME&#39;
        // set, and all other parts unset.  In particular, the &#39;FRACSECONDS&#39;
        // part is unset.
        // Note that the final &#39;TimeTag&#39; parameter is used purely to
        // disambiguate this constructor from that for year, month, and day.
        // A constuctor for 4 PM would be written as follows:
        //..
        //  Datetime dt = Datetime(16, 0, 0, Datetime::TimeTag());
        //..
        // Note that this constructor is intended for internal use only; client
        // code should use the &#39;createTime&#39; interface.

  public:
    struct Milliseconds {
        int d_msec;
        explicit Milliseconds(int milliseconds);
            // The behavior is undefined unless &#39;0 &lt;= milliseconds &lt; 1000&#39;.
    };
    struct Microseconds {
        int d_usec;
        explicit Microseconds(int microseconds);
            // The behavior is undefined unless
            // &#39;0 &lt;= microseconds &lt; 1,000,000&#39;.
    };
    struct Nanoseconds {
        int d_nsec;
        explicit Nanoseconds(int nanoseconds);
            // The behavior is undefined unless
            // &#39;0 &lt;= nanoseconds &lt; 1,000,000,000&#39;.
    };
    struct Picoseconds {
        long long d_psec;
        explicit Picoseconds(long long picoseconds);
            // The behavior is undefined unless
            // &#39;0 &lt;= picoseconds &lt; 1,000,000,000,000&#39;.
    };
    struct Offset {
        short d_minutesAheadOfUTC;
        explicit Offset(short minutesAheadOfUTC);
            // The behavior is undefined unless
            // &#39;-840 &lt;= minutesAheadOfUTC &lt;= 840&#39;.
    };

    static bool isValidDate(int year, int month, int day);
        // Return &#39;true&#39; if the specified &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; represent
        // a valid calendar date, and &#39;false&#39; otherwise.  Note that many
        // functions within &#39;Datetime&#39; provide defined behavior only when valid
        // dates are provided as arguments.

    static bool isValidTime(int          hours,
                            int          minutes,
                            int          seconds);
    static bool isValidTime(int          hours,
                            int          minutes,
                            int          seconds,
                            int          milliSeconds);
    static bool isValidTime(int          hours,
                            int          minutes,
                            int          seconds,
                            Milliseconds fractionOfSecond);
    static bool isValidTime(int          hours,
                            int          minutes,
                            int          seconds,
                            Microseconds fractionOfSecond);
    static bool isValidTime(int          hours,
                            int          minutes,
                            int          seconds,
                            Nanoseconds  fractionOfSecond);
    static bool isValidTime(int          hours,
                            int          minutes,
                            int          seconds,
                            Picoseconds  fractionOfSecond);
        // Return &#39;true&#39; if the specified &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // (optionally specified) &#39;milliseconds&#39; or &#39;fractionOfSecond&#39;
        // represent a valid time of day, and &#39;false&#39; otherwise.  Note that
        // many functions within &#39;Datetime&#39; provide defined behavior only when
        // valid times are provided as arguments.

    // CREATORS
    static Datetime createDatetime(unsigned year,
                                   unsigned month,
                                   unsigned day,
                                   unsigned hours,
                                   unsigned minutes,
                                   unsigned seconds);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39;
        // parts.  The behavior is undefined unless &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;
        // represent a valid date as specified by the &#39;isValidDate&#39; function,
        // and &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39; represent a valid time as
        // specified by the &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39;
        // object has the parts specified by &#39;DATE&#39; and &#39;TIME&#39; set, and the
        // &#39;OFFSET&#39; and &#39;FRACSECONDS&#39; parts unset.

    static Datetime createDatetime(unsigned year,
                                   unsigned month,
                                   unsigned day,
                                   unsigned hours,
                                   unsigned minutes,
                                   unsigned seconds,
                                   Offset   offset);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;offset&#39; parts.  The behavior is undefined unless &#39;year&#39;, &#39;month&#39;,
        // and &#39;day&#39; represent a valid date as specified by the &#39;isValidDate&#39;
        // function, and &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39; represent a valid
        // time as specified by the &#39;isValidTime&#39; function.  The resulting
        // &#39;Datetime&#39; object has the parts specified by &#39;DATE&#39;, &#39;TIME&#39;, and
        // &#39;OFFSET&#39; set, and the &#39;FRACSECONDS&#39; part unset.

    static Datetime createDatetime(unsigned     year,
                                   unsigned     month,
                                   unsigned     day,
                                   unsigned     hours,
                                   unsigned     minutes,
                                   unsigned     seconds,
                                   Milliseconds fractionOfSecond);
    static Datetime createDatetime(unsigned     year,
                                   unsigned     month,
                                   unsigned     day,
                                   unsigned     hours,
                                   unsigned     minutes,
                                   unsigned     seconds,
                                   Microseconds fractionOfSecond);
    static Datetime createDatetime(unsigned    year,
                                   unsigned    month,
                                   unsigned    day,
                                   unsigned    hours,
                                   unsigned    minutes,
                                   unsigned    seconds,
                                   Nanoseconds fractionOfSecond);
    static Datetime createDatetime(unsigned    year,
                                   unsigned    month,
                                   unsigned    day,
                                   unsigned    hours,
                                   unsigned    minutes,
                                   unsigned    seconds,
                                   Picoseconds fractionOfSecond);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;fractionOfSecond&#39;.  The behavior is undefined unless &#39;year&#39;,
        // &#39;month&#39;, and &#39;day&#39; represent a valid date as specified by the
        // &#39;isValidDate&#39; function, and &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;fractionOfSecond&#39; represent a valid time as specified by the
        // &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39; object has the
        // parts specified by &#39;DATE&#39; and &#39;TIMEFRACSECONDS&#39; set, and the
        // &#39;OFFSET&#39; part unset.

    static Datetime createDatetime(unsigned     year,
                                   unsigned     month,
                                   unsigned     day,
                                   unsigned     hours,
                                   unsigned     minutes,
                                   unsigned     seconds,
                                   Milliseconds fractionOfSecond,
                                   Offset       offset);
    static Datetime createDatetime(unsigned     year,
                                   unsigned     month,
                                   unsigned     day,
                                   unsigned     hours,
                                   unsigned     minutes,
                                   unsigned     seconds,
                                   Microseconds fractionOfSecond,
                                   Offset       offset);
    static Datetime createDatetime(unsigned     year,
                                   unsigned     month,
                                   unsigned     day,
                                   unsigned     hours,
                                   unsigned     minutes,
                                   unsigned     seconds,
                                   Nanoseconds  fractionOfSecond,
                                   Offset       offset);
    static Datetime createDatetime(unsigned     year,
                                   unsigned     month,
                                   unsigned     day,
                                   unsigned     hours,
                                   unsigned     minutes,
                                   unsigned     seconds,
                                   Picoseconds  fractionOfSecond,
                                   Offset       offset);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;,
        // &#39;fractionOfSecond&#39;, and &#39;offset&#39;.  The behavior is undefined unless
        // &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; represent a valid date as specified by
        // the &#39;isValidDate&#39; function, and &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;fractionOfSecond&#39; represent a valid time as specified by the
        // &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39; object has all
        // parts set.

    static Datetime createDate(unsigned year,
                               unsigned month,
                               unsigned day);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;.  The behavior is undefined
        // unless &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; represent a valid date as
        // specified by the &#39;isValidDate&#39; function.  The resulting &#39;Datetime&#39;
        // object has the parts specified by &#39;DATE&#39; set, and all other parts
        // unset.

    static Datetime createTime(unsigned hours,
                               unsigned minutes,
                               unsigned seconds);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39;.  The
        // behavior is undefined unless &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39;
        // represent a valid time as specified by the &#39;isValidTime&#39; function.
        // The resulting &#39;Datetime&#39; object has the parts specified by &#39;TIME&#39;
        // set, and all other parts unset.  Note that the &#39;FRACSECONDS&#39; part is
        // unset.

    static Datetime createTime(unsigned hours,
                               unsigned minutes,
                               unsigned seconds,
                               Offset   offset);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and &#39;offset&#39;.  The
        // behavior is undefined unless &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39;
        // represent a valid time as specified by the &#39;isValidTime&#39; function.
        // The resulting &#39;Datetime&#39; object has the parts specified by &#39;TIME&#39;
        // and &#39;OFFSET&#39; set, and all other parts unset.  Note that the
        // &#39;FRACSECONDS&#39; part is unset.

    static Datetime createTime(unsigned hours,
                               unsigned minutes,
                               unsigned seconds,
                               unsigned milliseconds);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and &#39;milliseconds&#39;.  The
        // behavior is undefined unless &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;milliseconds&#39; represent a valid time as specified by the
        // &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39; object has the
        // parts specified by &#39;TIMEFRACSECONDS&#39; set, and all other parts unset.

    static Datetime createTime(unsigned hours,
                               unsigned minutes,
                               unsigned seconds,
                               unsigned milliseconds,
                               Offset   offset);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, &#39;milliseconds&#39;, and
        // &#39;offset&#39;.  The behavior is undefined unless &#39;hours&#39;, &#39;minutes&#39;,
        // &#39;seconds&#39;, and &#39;milliseconds&#39; represent a valid time as specified by
        // the &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39; object has the
        // parts specified by &#39;TIMEFRACSECONDS&#39; and &#39;OFFSET&#39; set, and all other
        // parts unset.

    static Datetime createTime(unsigned     hours,
                               unsigned     minutes,
                               unsigned     seconds,
                               Milliseconds fractionOfSecond);
    static Datetime createTime(unsigned     hours,
                               unsigned     minutes,
                               unsigned     seconds,
                               Microseconds fractionOfSecond);
    static Datetime createTime(unsigned     hours,
                               unsigned     minutes,
                               unsigned     seconds,
                               Nanoseconds  fractionOfSecond);
    static Datetime createTime(unsigned     hours,
                               unsigned     minutes,
                               unsigned     seconds,
                               Picoseconds  fractionOfSecond);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and &#39;fractionOfSecond&#39;.
        // The behavior is undefined unless &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;fractionOfSecond&#39; represent a valid time as specified by the
        // &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39; object has the
        // parts specified by &#39;TIMEFRACSECONDS&#39; set, and all other
        // parts unset.

    static Datetime createTime(unsigned     hours,
                               unsigned     minutes,
                               unsigned     seconds,
                               Milliseconds fractionOfSecond,
                               Offset       offset);
    static Datetime createTime(unsigned     hours,
                               unsigned     minutes,
                               unsigned     seconds,
                               Microseconds fractionOfSecond,
                               Offset       offset);
    static Datetime createTime(unsigned     hours,
                               unsigned     minutes,
                               unsigned     seconds,
                               Nanoseconds  fractionOfSecond,
                               Offset       offset);
    static Datetime createTime(unsigned     hours,
                               unsigned     minutes,
                               unsigned     seconds,
                               Picoseconds  fractionOfSecond,
                               Offset       offset);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, &#39;fractionOfSecond&#39;, and
        // &#39;offset&#39;.  The behavior is undefined unless &#39;hours&#39;, &#39;minutes&#39;,
        // &#39;seconds&#39;, and &#39;fractionOfSecond&#39; represent a valid time as
        // specified by the &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39;
        // object has the parts specified by &#39;TIMEFRACSECONDS&#39; and &#39;OFFSET&#39;
        // set, and all other parts unset.

    Datetime();
        // Construct a &#39;Datetime&#39; object with all parts unset.

    Datetime(const Datetime&amp; original);
        // Copy constructor.

    Datetime(const blpapi_Datetime_t&amp; rawValue);

    explicit Datetime(const blpapi_HighPrecisionDatetime_t&amp; rawValue);

    Datetime(unsigned year,
             unsigned month,
             unsigned day,
             unsigned hours,
             unsigned minutes,
             unsigned seconds);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39;
        // parts.  The behavior is undefined unless &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;
        // represent a valid date as specified by the &#39;isValidDate&#39; function,
        // and &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39; represent a valid time as
        // specified by the &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39;
        // object has the parts specified by &#39;DATE&#39; and &#39;TIME&#39; set, and the
        // &#39;OFFSET&#39; and &#39;FRACSECONDS&#39; parts unset.
        // Use of this function is discouraged; use &#39;createDatetime&#39; instead.

    Datetime(unsigned year,
             unsigned month,
             unsigned day,
             unsigned hours,
             unsigned minutes,
             unsigned seconds,
             unsigned milliseconds);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;milliseconds&#39;.  The behavior is undefined unless &#39;year&#39;, &#39;month&#39;,
        // and &#39;day&#39; represent a valid date as specified by the &#39;isValidDate&#39;
        // function, and &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and &#39;milliseconds&#39;
        // represent a valid time as specified by the &#39;isValidTime&#39; function.
        // The resulting &#39;Datetime&#39; object has the parts specified by &#39;DATE&#39;
        // and &#39;TIMEFRACSECONDS&#39; set, and the &#39;OFFSET&#39; part unset.
        // Use of this function is discouraged; use &#39;createDatetime&#39; instead.

    Datetime(unsigned     year,
             unsigned     month,
             unsigned     day,
             unsigned     hours,
             unsigned     minutes,
             unsigned     seconds,
             Milliseconds fractionOfSecond);
    Datetime(unsigned     year,
             unsigned     month,
             unsigned     day,
             unsigned     hours,
             unsigned     minutes,
             unsigned     seconds,
             Microseconds fractionOfSecond);
    Datetime(unsigned    year,
             unsigned    month,
             unsigned    day,
             unsigned    hours,
             unsigned    minutes,
             unsigned    seconds,
             Nanoseconds fractionOfSecond);
    Datetime(unsigned    year,
             unsigned    month,
             unsigned    day,
             unsigned    hours,
             unsigned    minutes,
             unsigned    seconds,
             Picoseconds fractionOfSecond);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;fractionOfSecond&#39;.  The behavior is undefined unless &#39;year&#39;,
        // &#39;month&#39;, and &#39;day&#39; represent a valid date as specified by the
        // &#39;isValidDate&#39; function, and &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;fractionOfSecond&#39; represent a valid time as specified by the
        // &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39; object has the
        // parts specified by &#39;DATE&#39; and &#39;TIMEFRACSECONDS&#39; set, and the
        // &#39;OFFSET&#39; part unset.
        // Use of these functions is discouraged; use &#39;createDatetime&#39; instead.

    Datetime(unsigned year,
             unsigned month,
             unsigned day);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;.  The behavior is undefined
        // unless &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; represent a valid date as
        // specified by the &#39;isValidDate&#39; function.  The resulting &#39;Datetime&#39;
        // object has the parts specified by &#39;DATE&#39; set, and all other parts
        // unset.
        // Note that constructing a &#39;Datetime&#39; from three integers produces a
        // date; to create a time from hour, minute, and second (without the
        // fraction-of-second part unset) use the constructor taking a
        // &#39;TimeTag&#39;.
        // Use of this function is discouraged; use &#39;createDate&#39; instead.


    Datetime(unsigned hours,
             unsigned minutes,
             unsigned seconds,
             unsigned milliseconds);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and &#39;milliseconds&#39;.  The
        // behavior is undefined unless &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;milliseconds&#39; represent a valid time as specified by the
        // &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39; object has the
        // parts specified by &#39;TIMEFRACSECONDS&#39; set, and all other parts unset.
        // Note that removing the final argument from a call to this function
        // results in a constructor creating a date, not a time.

    Datetime(unsigned     hours,
             unsigned     minutes,
             unsigned     seconds,
             Milliseconds fractionOfSecond);
    Datetime(unsigned     hours,
             unsigned     minutes,
             unsigned     seconds,
             Microseconds fractionOfSecond);
    Datetime(unsigned     hours,
             unsigned     minutes,
             unsigned     seconds,
             Nanoseconds  fractionOfSecond);
    Datetime(unsigned     hours,
             unsigned     minutes,
             unsigned     seconds,
             Picoseconds  fractionOfSecond);
        // Create a &#39;Datetime&#39; object having the value representing the
        // specified &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and &#39;fractionOfSecond&#39;.
        // The behavior is undefined unless &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and
        // &#39;fractionOfSecond&#39; represent a valid time as specified by the
        // &#39;isValidTime&#39; function.  The resulting &#39;Datetime&#39; object has the
        // parts specified by &#39;TIMEFRACSECONDS&#39; set, and all other parts unset.
        // Note that removing the final argument from a call to this function
        // results in a constructor creating a date, not a time.

    // MANIPULATORS

    Datetime&amp; operator=(const Datetime&amp; rhs);
        // Assignment operator.

    void setDate(unsigned year,
                 unsigned month,
                 unsigned day);
        // Set the &#39;DATE&#39; parts of this &#39;Datetime&#39; object to the specified
        // &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;.  The behavior is undefined unless
        // &#39;isValidDate(year, month, day)&#39; would return &#39;true&#39;.

    void setTime(unsigned hours,
                 unsigned minutes,
                 unsigned seconds);
        // Set the &#39;TIME&#39; parts of this &#39;Datetime&#39; object to the specified
        // &#39;hours&#39;, &#39;minutes&#39;, and &#39;seconds&#39;, and mark the &#39;FRACSECONDS&#39; part
        // of this &#39;Datetime&#39; as unset.  The behavior is undefined unless
        // &#39;isValidTime(hours, minutes, seconds)&#39; would return &#39;true&#39;.

    void setTime(unsigned hours,
                 unsigned minutes,
                 unsigned seconds,
                 unsigned milliseconds);
        // Set the &#39;TIMEFRACSECONDS&#39; parts of this &#39;Datetime&#39; object to the
        // specified &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and &#39;milliseconds&#39;.  The
        // behavior is undefined unless
        // &#39;isValidTime(hours, minutes, seconds, milliseconds)&#39; would return
        // &#39;true&#39;.

    void setTime(unsigned     hours,
                 unsigned     minutes,
                 unsigned     seconds,
                 Milliseconds fractionOfSecond);
    void setTime(unsigned     hours,
                 unsigned     minutes,
                 unsigned     seconds,
                 Microseconds fractionOfSecond);
    void setTime(unsigned    hours,
                 unsigned    minutes,
                 unsigned    seconds,
                 Nanoseconds fractionOfSecond);
    void setTime(unsigned    hours,
                 unsigned    minutes,
                 unsigned    seconds,
                 Picoseconds fractionOfSecond);
        // Set the &#39;TIMEFRACSECONDS&#39; parts of this &#39;Datetime&#39; object to the
        // specified &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, and &#39;fractionOfSecond&#39;.
        // The behavior is undefined unless
        // &#39;isValidTime(hours, minutes, seconds, fractionOfSecond)&#39; would
        // return &#39;true&#39;.

    void setOffset(short minutesAheadOfUTC);
        // Set the &#39;OFFSET&#39; (i.e. timezone) part of this &#39;Datetime&#39; object to
        // the specified &#39;minutesAheadOfUTC&#39;.
        // The behavior is undefined unless &#39;-840 &lt;= minutesAheadOfUTC &lt;= 840&#39;.

    void setYear(unsigned value);
        // Set the &#39;YEAR&#39; part of this &#39;Datetime&#39; object to the specified
        // &#39;value&#39;.
        // The behavior is undefined unless &#39;1 &lt;= value &lt;= 9999&#39;, and either
        // the &#39;MONTH&#39; part is not set, the &#39;DAY&#39; part is not set, or
        // &#39;isValidDate(value. this-&gt;month(), this-&gt;day()) == true&#39;.

    void setMonth(unsigned value);
        // Set the &#39;MONTH&#39; part of this &#39;Datetime&#39; object to the specified
        // &#39;value&#39;.
        // The behavior is undefined unless &#39;1 &lt;= value &lt;= 12&#39;, and either the
        // &#39;DAY&#39; part is not set, the &#39;YEAR&#39; part is not set, or
        // &#39;isValidDate(this-&gt;year(). value, this-&gt;day()) == true&#39;.

    void setDay(unsigned value);
        // Set the &#39;DAY&#39; part of this &#39;Datetime&#39; object to the specified
        // &#39;value&#39;.
        // The behavior is undefined unless &#39;1 &lt;= value &lt;= 31&#39;, and either the
        // &#39;MONTH&#39; part is not set, the &#39;YEAR&#39; part is not set, or
        // &#39;isValidDate(this-&gt;year(). this-&gt;month(), value) == true&#39;.

    void setHours(unsigned value);
        // Set the &#39;HOURS&#39; part of this &#39;Datetime&#39; object to the specified
        // &#39;value&#39;.
        // The behavior is undefined unless &#39;0 &lt;= value &lt;= 23&#39;.

    void setMinutes(unsigned value);
        // Set the &#39;MINUTES&#39; part of this &#39;Datetime&#39; object to the specified
        // &#39;value&#39;.
        // The behavior is undefined unless &#39;0 &lt;= value &lt;= 59&#39;.

    void setSeconds(unsigned value);
        // Set the &#39;SECONDS&#39; part of this &#39;Datetime&#39; object to the specified
        // &#39;value&#39;.
        // The behavior is undefined unless &#39;0 &lt;= value &lt;= 59&#39;.

    void setMilliseconds(unsigned milliseconds);
        // Set the &#39;FRACSECONDS&#39; part of this &#39;Datetime&#39; object to the
        // specified &#39;milliseconds&#39;.
        // The behavior is undefined unless &#39;0 &lt;= value &lt;= 999&#39;.

    void setFractionOfSecond(Milliseconds value);
        // Set the &#39;FRACSECONDS&#39; part of this &#39;Datetime&#39; object to the
        // Set the fraction of a second of the value of this object to the
        // specified &#39;value&#39;.  Note that the behavior is undefined unless
        // &#39;0 &lt;= value &lt;= 999 ms&#39;.

    void setFractionOfSecond(Microseconds value);
        // Set the &#39;FRACSECONDS&#39; part of this &#39;Datetime&#39; object to the
        // specified &#39;value&#39;. Note that the behavior is undefined unless
        // &#39;0 &lt;= value &lt;= 999,999 us&#39;.

    void setFractionOfSecond(Nanoseconds value);
        // Set the &#39;FRACSECONDS&#39; part of this &#39;Datetime&#39; object to the
        // specified &#39;value&#39;.  Note that the behavior is undefined unless
        // &#39;0 &lt;= value &lt;= 999,999,999 ns&#39;.

    void setFractionOfSecond(Picoseconds value);
        // Set the &#39;FRACSECONDS&#39; part of this &#39;Datetime&#39; object to the
        // specified &#39;value&#39;.  Note that the behavior is undefined unless
        // &#39;0 &lt;= value &lt;= 999,999,999,999 ps&#39;.

    blpapi_Datetime_t&amp; rawValue();
        // Return a (modifiable) reference to the millisecond-resolution C
        // struct underlying this object.  Behavior of the object is undefined
        // if the returned struct is modified concurrently with other non-const
        // methods of this object, or if the fields of the &#39;blpapi_Datetime_t&#39;
        // are modified such that the &#39;Datetime::isValid&#39; methods of this class
        // would return &#39;false&#39; when passed those fields of the struct whose
        // bits are set in the struct&#39;s &#39;parts&#39; field.  Further, direct setting
        // of the &#39;FRACSECONDS&#39; bit in the returned struct&#39;s &#39;parts&#39; field will
        // cause this &#39;Datetime&#39; object to compute its fraction-of-second part
        // not just from the struct&#39;s &#39;milliSeconds&#39; field, but also from the
        // &#39;picoseconds&#39; field of the the struct returned from
        // &#39;rawHighPrecisionValue()&#39;; if neither that field nor this &#39;Datetime&#39;
        // objects&#39; fraction-of-second part have been initialized, then
        // the behavior of setting the &#39;FRACSECONDS&#39; bit directly is undefined.

    blpapi_HighPrecisionDatetime_t&amp; rawHighPrecisionValue();
        // Return a (modifiable) reference to the high-resolution C struct
        // underlying this object.  Behavior of the object is undefined if the
        // returned struct is modified concurrently with other non-const
        // methods of this object, or if the fields of the
        // &#39;blpapi_HighPrecisionDatetime_t&#39; are modified such that the
        // &#39;Datetime::isValid*&#39; methods of this class would return &#39;false&#39; when
        // passed those fields of the struct whose bits are set in the struct&#39;s
        // &#39;parts&#39; field.

    // ACCESSORS
    bool hasParts(unsigned parts) const;
        // Return true if this &#39;Datetime&#39; object has all of the specified
        // &#39;parts&#39; set.  The &#39;parts&#39; parameter must be constructed by or&#39;ing
        // together values from the &#39;DatetimeParts&#39; enum.

    unsigned parts() const;
        // Return a bitmask of all parts that are set in this &#39;Datetime&#39;
        // object.  This can be compared to the values in the &#39;DatetimeParts&#39;
        // enum using bitwise operations.

    unsigned year() const;
        // Return the year value of this &#39;Datetime&#39; object.  The result is
        // undefined unless the &#39;YEAR&#39; part of this object is set.

    unsigned month() const;
        // Return the month value of this &#39;Datetime&#39; object.  The result is
        // undefined unless the &#39;MONTH&#39; part of this object is set.

    unsigned day() const;
        // Return the day value of this &#39;Datetime&#39; object.  The result is
        // undefined unless the &#39;DAY&#39; part of this object is set.

    unsigned hours() const;
        // Return the hours value of this &#39;Datetime&#39; object.  The result is
        // undefined unless the &#39;HOURS&#39; part of this object is set.

    unsigned minutes() const;
        // Return the minutes value of this &#39;Datetime&#39; object.  The result is
        // undefined unless the &#39;MINUTES&#39; part of this object is set.

    unsigned seconds() const;
        // Return the seconds value of this &#39;Datetime&#39; object.  The result is
        // undefined unless the &#39;SECONDS&#39; part of this object is set.

    unsigned milliSeconds() const;
        // Return the milliseconds value of this &#39;Datetime&#39; object.  The result
        // is undefined unless the &#39;FRACSECONDS&#39; part of this object is set.
        // This function is deprecated; use &#39;milliseconds()&#39; instead.

    unsigned milliseconds() const;
        // Return the number of (whole) milliseconds in the
        // fraction-of-a-second part of the value of this object.  The result
        // is undefined unless the &#39;FRACSECONDS&#39; part of this object is set.

    unsigned microseconds() const;
        // Return the number of (whole) microseconds in the
        // fraction-of-a-second part of the value of this object.  The result
        // is undefined unless the &#39;FRACSECONDS&#39; part of this object is set.

    unsigned nanoseconds() const;
        // Return the number of (whole) nanoseconds in the fraction-of-a-second
        // part of the value of this object.  The result is undefined unless
        // the &#39;FRACSECONDS&#39; part of this object is set.

    unsigned long long picoseconds() const;
        // Return the number of (whole) picoseconds in the fraction-of-a-second
        // part of the value of this object.  The result is undefined unless
        // the &#39;FRACSECONDS&#39; part of this object is set.

    short offset() const;
        // Return the number of minutes this &#39;Datetime&#39; object is ahead of UTC.
        // The result is undefined unless the &#39;OFFSET&#39; part of this object is
        // set.

    const blpapi_Datetime_t&amp; rawValue() const;
        // Return a (read-only) reference to the millisecond-resolution C
        // struct underlying this object.

    const blpapi_HighPrecisionDatetime_t&amp; rawHighPrecisionValue() const;
        // Return a (read-only) reference to the high-precision C struct
        // underlying this object.

    bool isValid() const;
        // Check whether the value of this &#39;Datetime&#39; is valid.  The behaviour
        // is undefined unless this object represents a date (has YEAR, MONTH
        // and DAY part set) or time (has HOURS, MINUTES, SECONDS and
        // MILLISECONDS part set).  Note that in almost all cases where this
        // function returns &#39;false&#39;, prior member function calls have had
        // undefined behavior.
        // This function is deprecated; use &#39;isValidDate&#39; and/or &#39;isValidTime&#39;
        // directly instead.

    std::ostream&amp; print(std::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Write the value of this object to the specified output &#39;stream&#39; in
        // a human-readable format, and return a reference to &#39;stream&#39;.
        // Optionally specify an initial indentation &#39;level&#39;, whose absolute
        // value is incremented recursively for nested objects.  If &#39;level&#39; is
        // specified, optionally specify &#39;spacesPerLevel&#39;, whose absolute
        // value indicates the number of spaces per indentation level for this
        // and all of its nested objects.  If &#39;level&#39; is negative, suppress
        // indentation of the first line.  If &#39;spacesPerLevel&#39; is negative,
        // format the entire output on one line, suppressing all but the
        // initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is not
        // valid on entry, this operation has no effect.  Note that this
        // human-readable format is not fully specified, and can change
        // without notice.

};

// FREE OPERATORS
bool operator==(const Datetime&amp; lhs, const Datetime&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value, and
    // &#39;false&#39; otherwise.  Two &#39;Datetime&#39; objects have the same value if they
    // have the same parts set, and the same values for each of those parts.

bool operator!=(const Datetime&amp; lhs, const Datetime&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; do not have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Datetime&#39; objects have the same
    // value if they have the same parts set, and the same values for each of
    // those parts.

bool operator&lt;(const Datetime&amp; lhs, const Datetime&amp; rhs);
bool operator&lt;=(const Datetime&amp; lhs, const Datetime&amp; rhs);
bool operator&gt;(const Datetime&amp; lhs, const Datetime&amp; rhs);
bool operator&gt;=(const Datetime&amp; lhs, const Datetime&amp; rhs);
    // Compare the specified &#39;lhs&#39; and &#39;rhs&#39;.  The ordering used is temporal,
    // with earlier moments comparing less than later moments, in the case that
    // &#39;lhs.parts() == rhs.parts()&#39; and &#39;parts()&#39; is one of &#39;DATE&#39;, &#39;TIME&#39;,
    // &#39;TIMEFRACSECONDS&#39;, &#39;DATE | TIME&#39;, and &#39;DATE | TIMEFRACSECONDS&#39;; the
    // ordering in all other cases is unspecified, but guaranteed stable within
    // process.

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Datetime&amp; datetime);
    // Write the value of the specified &#39;datetime&#39; object to the specified
    // output &#39;stream&#39; in a single-line format, and return a reference to
    // &#39;stream&#39;.  If &#39;stream&#39; is not valid on entry, this operation has no
    // effect.  Note that this human-readable format is not fully specified,
    // can change without notice, and is logically equivalent to:
    //..
    //  print(stream, 0, -1);
    //..

                            // ===================
                            // struct DatetimeUtil
                            // ===================

struct DatetimeUtil {
    // This provides a namespace for &#39;Datetime&#39; utility functions.

    static Datetime fromTimePoint(
                                const TimePoint&amp; timePoint,
                                Datetime::Offset offset = Datetime::Offset(0));
        // Create and return a &#39;Datetime&#39; object having the value of the
        // specified &#39;timePoint&#39; and the optionally specified timezone
        // &#39;offset&#39;, 0 by default. The resulting &#39;Datetime&#39; object has the
        // parts specified by &#39;DATE&#39;, &#39;TIMEFRACSECONDS&#39;, and &#39;OFFSET&#39; set.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                            // --------------
                            // class Datetime
                            // --------------

inline
bool Datetime::isLeapYear(int y)
{
    return 0 == y % 4 &amp;&amp; (y &lt;= 1752 || 0 != y % 100 || 0 == y % 400);
}

inline
Datetime::Datetime(unsigned hours,
                   unsigned minutes,
                   unsigned seconds,
                   TimeTag)
{
    std::memset(&amp;d_value, 0, sizeof(d_value));
    setTime(hours, minutes, seconds);
}

inline
Datetime::Milliseconds::Milliseconds(int milliseconds)
: d_msec(milliseconds)
{
}

inline
Datetime::Microseconds::Microseconds(int microseconds)
: d_usec(microseconds)
{
}

inline
Datetime::Nanoseconds::Nanoseconds(int nanoseconds)
: d_nsec(nanoseconds)
{
}

inline
Datetime::Picoseconds::Picoseconds(long long picoseconds)
: d_psec(picoseconds)
{
}

inline
Datetime::Offset::Offset(short minutesAheadOfUTC)
: d_minutesAheadOfUTC(minutesAheadOfUTC)
{
}

inline
bool Datetime::isValidDate(int year,
                           int month,
                           int day)
{
    if ((year &lt;= 0) || (year &gt; 9999) ||
        (month &lt;= 0) || (month &gt; 12) ||
        (day &lt;= 0) || (day &gt; 31) ) {
        return false;
    }
    if (day &lt; 29) {
        return true;
    }
    if (year == 1752) {
        if (month == 9 &amp;&amp; day &gt; 2 &amp;&amp; day &lt; 14) {
            return false;
        }
    }
    switch (month) {
      case 1:
      case 3:
      case 5:
      case 7:
      case 8:
      case 10:
      case 12:
        return true;

      case 4:
      case 6:
      case 9:
      case 11: {
        if (day &gt; 30) {
            return false;
        }
        else {
            return true;
        }
      }
      case 2: {
        if (isLeapYear(year)) {
            if (day &gt; 29) {
                return false;
            }
            else {
                return true;
            }
        }
        else if (day &gt; 28) {
            return false;
        }
        else {
            return true;
        }
      }
      default: {
        return true;
      }
    }
}

inline
bool Datetime::isValidTime(int hours,
                           int minutes,
                           int seconds) {
    return (hours &gt;= 0) &amp;&amp; (hours &lt; 24)
        &amp;&amp; (minutes &gt;= 0) &amp;&amp; (minutes &lt; 60)
        &amp;&amp; (seconds &gt;= 0) &amp;&amp; (seconds &lt; 60);
}

inline
bool Datetime::isValidTime(int hours,
                           int minutes,
                           int seconds,
                           int milliSeconds)
{
    return (hours &gt;= 0) &amp;&amp; (hours &lt; 24)
        &amp;&amp; (minutes &gt;= 0) &amp;&amp; (minutes &lt; 60)
        &amp;&amp; (seconds &gt;= 0) &amp;&amp; (seconds &lt; 60)
        &amp;&amp; (milliSeconds &gt;= 0) &amp;&amp; (milliSeconds &lt; 1000);
}

inline
bool Datetime::isValidTime(int          hours,
                           int          minutes,
                           int          seconds,
                           Milliseconds fractionOfSecond)
{
    return isValidTime(hours, minutes, seconds, fractionOfSecond.d_msec);
}

inline
bool Datetime::isValidTime(int          hours,
                           int          minutes,
                           int          seconds,
                           Microseconds fractionOfSecond)
{
    return (hours &gt;= 0) &amp;&amp; (hours &lt; 24)
        &amp;&amp; (minutes &gt;= 0) &amp;&amp; (minutes &lt; 60)
        &amp;&amp; (seconds &gt;= 0) &amp;&amp; (seconds &lt; 60)
        &amp;&amp; (fractionOfSecond.d_usec &gt;= 0)
        &amp;&amp; (fractionOfSecond.d_usec &lt; 1000 * 1000);
}

inline
bool Datetime::isValidTime(int         hours,
                           int         minutes,
                           int         seconds,
                           Nanoseconds fractionOfSecond)
{
    return (hours &gt;= 0) &amp;&amp; (hours &lt; 24)
        &amp;&amp; (minutes &gt;= 0) &amp;&amp; (minutes &lt; 60)
        &amp;&amp; (seconds &gt;= 0) &amp;&amp; (seconds &lt; 60)
        &amp;&amp; (fractionOfSecond.d_nsec &gt;= 0)
        &amp;&amp; (fractionOfSecond.d_nsec &lt; 1000 * 1000 * 1000);
}

inline
bool Datetime::isValidTime(int         hours,
                           int         minutes,
                           int         seconds,
                           Picoseconds fractionOfSecond)
{
    return (hours &gt;= 0) &amp;&amp; (hours &lt; 24)
        &amp;&amp; (minutes &gt;= 0) &amp;&amp; (minutes &lt; 60)
        &amp;&amp; (seconds &gt;= 0) &amp;&amp; (seconds &lt; 60)
        &amp;&amp; (fractionOfSecond.d_psec &gt;= 0)
        &amp;&amp; (fractionOfSecond.d_psec &lt; 1000LL * 1000 * 1000 * 1000);
}

inline
Datetime Datetime::createDatetime(unsigned year,
                                  unsigned month,
                                  unsigned day,
                                  unsigned hours,
                                  unsigned minutes,
                                  unsigned seconds)
{
    return Datetime(year, month, day, hours, minutes, seconds);
}

inline
Datetime Datetime::createDatetime(unsigned year,
                                  unsigned month,
                                  unsigned day,
                                  unsigned hours,
                                  unsigned minutes,
                                  unsigned seconds,
                                  Offset   offset)
{
    Datetime dt(year, month, day, hours, minutes, seconds);
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}

inline
Datetime Datetime::createDatetime(unsigned     year,
                                  unsigned     month,
                                  unsigned     day,
                                  unsigned     hours,
                                  unsigned     minutes,
                                  unsigned     seconds,
                                  Milliseconds fractionOfSecond)
{
    return Datetime(year,
                    month,
                    day,
                    hours,
                    minutes,
                    seconds,
                    fractionOfSecond);
}

inline
Datetime Datetime::createDatetime(unsigned     year,
                                  unsigned     month,
                                  unsigned     day,
                                  unsigned     hours,
                                  unsigned     minutes,
                                  unsigned     seconds,
                                  Microseconds fractionOfSecond)
{
    return Datetime(year,
                    month,
                    day,
                    hours,
                    minutes,
                    seconds,
                    fractionOfSecond);
}

inline
Datetime Datetime::createDatetime(unsigned    year,
                                  unsigned    month,
                                  unsigned    day,
                                  unsigned    hours,
                                  unsigned    minutes,
                                  unsigned    seconds,
                                  Nanoseconds fractionOfSecond)
{
    return Datetime(year,
                    month,
                    day,
                    hours,
                    minutes,
                    seconds,
                    fractionOfSecond);
}

inline
Datetime Datetime::createDatetime(unsigned    year,
                                  unsigned    month,
                                  unsigned    day,
                                  unsigned    hours,
                                  unsigned    minutes,
                                  unsigned    seconds,
                                  Picoseconds fractionOfSecond)
{
    return Datetime(year,
                    month,
                    day,
                    hours,
                    minutes,
                    seconds,
                    fractionOfSecond);
}

inline
Datetime Datetime::createDatetime(unsigned     year,
                                  unsigned     month,
                                  unsigned     day,
                                  unsigned     hours,
                                  unsigned     minutes,
                                  unsigned     seconds,
                                  Milliseconds fractionOfSecond,
                                  Offset       offset)
{
    Datetime dt(year, month, day, hours, minutes, seconds, fractionOfSecond);
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}

inline
Datetime Datetime::createDatetime(unsigned     year,
                                  unsigned     month,
                                  unsigned     day,
                                  unsigned     hours,
                                  unsigned     minutes,
                                  unsigned     seconds,
                                  Microseconds fractionOfSecond,
                                  Offset       offset)
{
    Datetime dt(year, month, day, hours, minutes, seconds, fractionOfSecond);
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}

inline
Datetime Datetime::createDatetime(unsigned     year,
                                  unsigned     month,
                                  unsigned     day,
                                  unsigned     hours,
                                  unsigned     minutes,
                                  unsigned     seconds,
                                  Nanoseconds  fractionOfSecond,
                                  Offset       offset)
{
    Datetime dt(year, month, day, hours, minutes, seconds, fractionOfSecond);
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}

inline
Datetime Datetime::createDatetime(unsigned     year,
                                  unsigned     month,
                                  unsigned     day,
                                  unsigned     hours,
                                  unsigned     minutes,
                                  unsigned     seconds,
                                  Picoseconds  fractionOfSecond,
                                  Offset       offset)
{
    Datetime dt(year, month, day, hours, minutes, seconds, fractionOfSecond);
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}

inline
Datetime Datetime::createDate(unsigned year,
                              unsigned month,
                              unsigned day)
{
    return Datetime(year, month, day);
}

inline
Datetime Datetime::createTime(unsigned hours,
                              unsigned minutes,
                              unsigned seconds)
{
    return Datetime(hours, minutes, seconds, TimeTag());
}

inline
Datetime Datetime::createTime(unsigned hours,
                              unsigned minutes,
                              unsigned seconds,
                              Offset   offset)
{
    Datetime dt(hours, minutes, seconds, TimeTag());
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}

inline
Datetime Datetime::createTime(unsigned hours,
                              unsigned minutes,
                              unsigned seconds,
                              unsigned milliseconds)
{
    return Datetime(hours, minutes, seconds, milliseconds);
}

inline

Datetime Datetime::createTime(unsigned hours,
                              unsigned minutes,
                              unsigned seconds,
                              unsigned milliseconds,
                              Offset   offset)
{
    Datetime dt(hours, minutes, seconds, milliseconds);
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}

inline
Datetime Datetime::createTime(unsigned     hours,
                              unsigned     minutes,
                              unsigned     seconds,
                              Milliseconds fractionOfSecond)
{
    return Datetime(hours, minutes, seconds, fractionOfSecond);
}

inline
Datetime Datetime::createTime(unsigned     hours,
                              unsigned     minutes,
                              unsigned     seconds,
                              Microseconds fractionOfSecond)
{
    return Datetime(hours, minutes, seconds, fractionOfSecond);
}

inline
Datetime Datetime::createTime(unsigned     hours,
                              unsigned     minutes,
                              unsigned     seconds,
                              Nanoseconds  fractionOfSecond)
{
    return Datetime(hours, minutes, seconds, fractionOfSecond);
}

inline
Datetime Datetime::createTime(unsigned     hours,
                              unsigned     minutes,
                              unsigned     seconds,
                              Picoseconds  fractionOfSecond)
{
    return Datetime(hours, minutes, seconds, fractionOfSecond);
}

inline
Datetime Datetime::createTime(unsigned     hours,
                              unsigned     minutes,
                              unsigned     seconds,
                              Milliseconds fractionOfSecond,
                              Offset       offset)
{
    Datetime dt(hours, minutes, seconds, fractionOfSecond);
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}

inline
Datetime Datetime::createTime(unsigned     hours,
                              unsigned     minutes,
                              unsigned     seconds,
                              Microseconds fractionOfSecond,
                              Offset       offset)
{
    Datetime dt(hours, minutes, seconds, fractionOfSecond);
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}

inline
Datetime Datetime::createTime(unsigned     hours,
                              unsigned     minutes,
                              unsigned     seconds,
                              Nanoseconds  fractionOfSecond,
                              Offset       offset)
{
    Datetime dt(hours, minutes, seconds, fractionOfSecond);
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}

inline
Datetime Datetime::createTime(unsigned     hours,
                              unsigned     minutes,
                              unsigned     seconds,
                              Picoseconds  fractionOfSecond,
                              Offset       offset)
{
    Datetime dt(hours, minutes, seconds, fractionOfSecond);
    dt.setOffset(offset.d_minutesAheadOfUTC);
    return dt;
}


inline
Datetime::Datetime()
{
    std::memset(&amp;d_value, 0, sizeof(d_value));
    d_value.datetime.year = 1;
    d_value.datetime.month = 1;
    d_value.datetime.day = 1;
}

inline
Datetime::Datetime(const Datetime&amp; original)
: d_value(original.d_value)
{
}

inline
Datetime::Datetime(const blpapi_Datetime_t&amp; rawValue)
{
    d_value.datetime = rawValue;
    d_value.picoseconds = 0;
}

inline
Datetime::Datetime(const blpapi_HighPrecisionDatetime_t&amp; rawValue)
: d_value(rawValue)
{
}

inline
Datetime::Datetime(unsigned year,
                   unsigned month,
                   unsigned day,
                   unsigned hours,
                   unsigned minutes,
                   unsigned seconds)
{
    d_value.datetime.offset = 0;
    d_value.datetime.year = year;
    d_value.datetime.month = month;
    d_value.datetime.day = day;
    d_value.datetime.hours = hours;
    d_value.datetime.minutes = minutes;
    d_value.datetime.seconds = seconds;
    d_value.datetime.milliSeconds = 0;
    d_value.picoseconds = 0;
    d_value.datetime.parts = DatetimeParts::DATE | DatetimeParts::TIME;
}

inline
Datetime::Datetime(unsigned year,
                   unsigned month,
                   unsigned day,
                   unsigned hours,
                   unsigned minutes,
                   unsigned seconds,
                   unsigned milliSeconds)
{
    d_value.datetime.offset = 0;
    d_value.datetime.year = year;
    d_value.datetime.month = month;
    d_value.datetime.day = day;
    d_value.datetime.hours = hours;
    d_value.datetime.minutes = minutes;
    d_value.datetime.seconds = seconds;
    d_value.datetime.milliSeconds = milliSeconds;
    d_value.picoseconds = 0;
    d_value.datetime.parts
        = DatetimeParts::DATE | DatetimeParts::TIMEFRACSECONDS;
}

inline
Datetime::Datetime(unsigned     year,
                   unsigned     month,
                   unsigned     day,
                   unsigned     hours,
                   unsigned     minutes,
                   unsigned     seconds,
                   Milliseconds fractionOfSecond)
{
    d_value.datetime.offset = 0;
    d_value.datetime.year = year;
    d_value.datetime.month = month;
    d_value.datetime.day = day;
    d_value.datetime.hours = hours;
    d_value.datetime.minutes = minutes;
    d_value.datetime.seconds = seconds;
    d_value.datetime.milliSeconds = fractionOfSecond.d_msec;
    d_value.picoseconds = 0;
    d_value.datetime.parts
        = DatetimeParts::DATE | DatetimeParts::TIMEFRACSECONDS;
}

inline
Datetime::Datetime(unsigned     year,
                   unsigned     month,
                   unsigned     day,
                   unsigned     hours,
                   unsigned     minutes,
                   unsigned     seconds,
                   Microseconds fractionOfSecond)
{
    d_value.datetime.offset = 0;
    d_value.datetime.year = year;
    d_value.datetime.month = month;
    d_value.datetime.day = day;
    d_value.datetime.hours = hours;
    d_value.datetime.minutes = minutes;
    d_value.datetime.seconds = seconds;
    d_value.datetime.milliSeconds = fractionOfSecond.d_usec / 1000;
    d_value.picoseconds = (fractionOfSecond.d_usec % 1000) * 1000 * 1000;
    d_value.datetime.parts
        = DatetimeParts::DATE | DatetimeParts::TIMEFRACSECONDS;
}

inline
Datetime::Datetime(unsigned    year,
                   unsigned    month,
                   unsigned    day,
                   unsigned    hours,
                   unsigned    minutes,
                   unsigned    seconds,
                   Nanoseconds fractionOfSecond)
{
    d_value.datetime.offset = 0;
    d_value.datetime.year = year;
    d_value.datetime.month = month;
    d_value.datetime.day = day;
    d_value.datetime.hours = hours;
    d_value.datetime.minutes = minutes;
    d_value.datetime.seconds = seconds;
    d_value.datetime.milliSeconds = fractionOfSecond.d_nsec / 1000 / 1000;
    d_value.picoseconds = (fractionOfSecond.d_nsec % (1000 * 1000)) * 1000;
    d_value.datetime.parts
        = DatetimeParts::DATE | DatetimeParts::TIMEFRACSECONDS;
}

inline
Datetime::Datetime(unsigned    year,
                   unsigned    month,
                   unsigned    day,
                   unsigned    hours,
                   unsigned    minutes,
                   unsigned    seconds,
                   Picoseconds fractionOfSecond)
{
    d_value.datetime.offset = 0;
    d_value.datetime.year = year;
    d_value.datetime.month = month;
    d_value.datetime.day = day;
    d_value.datetime.hours = hours;
    d_value.datetime.minutes = minutes;
    d_value.datetime.seconds = seconds;
    d_value.datetime.milliSeconds = static_cast&lt;blpapi_UInt16_t&gt;(
                                 fractionOfSecond.d_psec / 1000 / 1000 / 1000);
    d_value.picoseconds = fractionOfSecond.d_psec % (1000 * 1000 * 1000);
    d_value.datetime.parts
        = DatetimeParts::DATE | DatetimeParts::TIMEFRACSECONDS;
}

inline
Datetime::Datetime(unsigned year,
                   unsigned month,
                   unsigned day)
{
    std::memset(&amp;d_value, 0, sizeof(d_value));
    setDate(year, month, day);
}

inline
Datetime::Datetime(unsigned hours,
                   unsigned minutes,
                   unsigned seconds,
                   unsigned milliSeconds)
{
    std::memset(&amp;d_value, 0, sizeof(d_value));
    setTime(hours, minutes, seconds, milliSeconds);
}

inline
Datetime::Datetime(unsigned     hours,
                   unsigned     minutes,
                   unsigned     seconds,
                   Milliseconds fractionOfSecond)
{
    std::memset(&amp;d_value, 0, sizeof(d_value));
    setTime(hours, minutes, seconds, fractionOfSecond);
}

inline
Datetime::Datetime(unsigned     hours,
                   unsigned     minutes,
                   unsigned     seconds,
                   Microseconds fractionOfSecond)
{
    std::memset(&amp;d_value, 0, sizeof(d_value));
    setTime(hours, minutes, seconds, fractionOfSecond);
}

inline
Datetime::Datetime(unsigned    hours,
                   unsigned    minutes,
                   unsigned    seconds,
                   Nanoseconds fractionOfSecond)
{
    std::memset(&amp;d_value, 0, sizeof(d_value));
    setTime(hours, minutes, seconds, fractionOfSecond);
}

inline
Datetime::Datetime(unsigned    hours,
                   unsigned    minutes,
                   unsigned    seconds,
                   Picoseconds fractionOfSecond)
{
    std::memset(&amp;d_value, 0, sizeof(d_value));
    setTime(hours, minutes, seconds, fractionOfSecond);
}

inline
Datetime&amp; Datetime::operator=(const Datetime&amp; rhs)
{
    d_value = rhs.d_value;
    return *this;
}

inline
void Datetime::setDate(unsigned year,
                       unsigned month,
                       unsigned day)
{
    d_value.datetime.day   = day;
    d_value.datetime.month = month;
    d_value.datetime.year  = year;
    d_value.datetime.parts |= DatetimeParts::DATE;
}

inline
void Datetime::setTime(unsigned hours,
                       unsigned minutes,
                       unsigned seconds)
{
    d_value.datetime.hours        = hours;
    d_value.datetime.minutes      = minutes;
    d_value.datetime.seconds      = seconds;
    d_value.datetime.milliSeconds = 0;
    d_value.picoseconds           = 0;
    d_value.datetime.parts        =  (d_value.datetime.parts
                                    &amp; ~DatetimeParts::FRACSECONDS)
                                    | DatetimeParts::TIME;
}


inline
void Datetime::setTime(unsigned hours,
                       unsigned minutes,
                       unsigned seconds,
                       unsigned milliSeconds)
{
    d_value.datetime.hours        = hours;
    d_value.datetime.minutes      = minutes;
    d_value.datetime.seconds      = seconds;
    d_value.datetime.milliSeconds = milliSeconds;
    d_value.picoseconds           = 0;
    d_value.datetime.parts       |= DatetimeParts::TIMEFRACSECONDS;
}


inline
void Datetime::setTime(unsigned     hours,
                       unsigned     minutes,
                       unsigned     seconds,
                       Milliseconds fractionOfSecond)
{
    d_value.datetime.hours        = hours;
    d_value.datetime.minutes      = minutes;
    d_value.datetime.seconds      = seconds;
    d_value.datetime.milliSeconds = fractionOfSecond.d_msec;
    d_value.picoseconds           = 0;
    d_value.datetime.parts       |= DatetimeParts::TIMEFRACSECONDS;
}


inline
void Datetime::setTime(unsigned     hours,
                       unsigned     minutes,
                       unsigned     seconds,
                       Microseconds fractionOfSecond)
{
    d_value.datetime.hours        = hours;
    d_value.datetime.minutes      = minutes;
    d_value.datetime.seconds      = seconds;
    d_value.datetime.milliSeconds = fractionOfSecond.d_usec / 1000;
    d_value.picoseconds           = fractionOfSecond.d_usec % 1000
                                                            * 1000
                                                            * 1000;
    d_value.datetime.parts       |= DatetimeParts::TIMEFRACSECONDS;
}


inline
void Datetime::setTime(unsigned    hours,
                       unsigned    minutes,
                       unsigned    seconds,
                       Nanoseconds fractionOfSecond)
{
    d_value.datetime.hours        = hours;
    d_value.datetime.minutes      = minutes;
    d_value.datetime.seconds      = seconds;
    d_value.datetime.milliSeconds = fractionOfSecond.d_nsec / 1000 / 1000;
    d_value.picoseconds           = fractionOfSecond.d_nsec % (1000 * 1000)
                                                            * 1000;
    d_value.datetime.parts       |= DatetimeParts::TIMEFRACSECONDS;
}


inline
void Datetime::setTime(unsigned    hours,
                       unsigned    minutes,
                       unsigned    seconds,
                       Picoseconds fractionOfSecond)
{
    d_value.datetime.hours        = hours;
    d_value.datetime.minutes      = minutes;
    d_value.datetime.seconds      = seconds;
    d_value.datetime.milliSeconds
        = static_cast&lt;blpapi_UInt16_t&gt;(fractionOfSecond.d_psec / 1000
                                                               / 1000
                                                               / 1000);
    d_value.picoseconds           = fractionOfSecond.d_psec % (  1000
                                                               * 1000
                                                               * 1000);
    d_value.datetime.parts       |= DatetimeParts::TIMEFRACSECONDS;
}


inline
void Datetime::setOffset(short value)
{
    d_value.datetime.offset = value;
    d_value.datetime.parts |= DatetimeParts::OFFSET;
}


inline
void Datetime::setYear(unsigned value)
{
    d_value.datetime.year   = value;
    d_value.datetime.parts |= DatetimeParts::YEAR;
}


inline
void Datetime::setMonth(unsigned value)
{
    d_value.datetime.month  = value;
    d_value.datetime.parts |= DatetimeParts::MONTH;
}


inline
void Datetime::setDay(unsigned value)
{
    d_value.datetime.day    = value;
    d_value.datetime.parts |= DatetimeParts::DAY;
}


inline
void Datetime::setHours(unsigned value)
{
    d_value.datetime.hours  = value;
    d_value.datetime.parts |= DatetimeParts::HOURS;
}


inline
void Datetime::setMinutes(unsigned value)
{
    d_value.datetime.minutes  = value;
    d_value.datetime.parts   |= DatetimeParts::MINUTES;
}


inline
void Datetime::setSeconds(unsigned value)
{
    d_value.datetime.seconds  = value;
    d_value.datetime.parts   |= DatetimeParts::SECONDS;
}


inline
void Datetime::setMilliseconds(unsigned value)
{
    d_value.datetime.milliSeconds = value;
    d_value.picoseconds           = 0;
    d_value.datetime.parts       |= DatetimeParts::FRACSECONDS;
}

inline
void Datetime::setFractionOfSecond(Milliseconds value)
{
    d_value.datetime.milliSeconds = value.d_msec;
    d_value.picoseconds           = 0;
    d_value.datetime.parts       |= DatetimeParts::FRACSECONDS;
}

inline
void Datetime::setFractionOfSecond(Microseconds value)
{
    d_value.datetime.milliSeconds = value.d_usec / 1000;
    d_value.picoseconds           = value.d_usec % 1000 * 1000 * 1000;
    d_value.datetime.parts       |= DatetimeParts::FRACSECONDS;
}

inline
void Datetime::setFractionOfSecond(Nanoseconds value)
{
    d_value.datetime.milliSeconds = value.d_nsec / 1000 / 1000;
    d_value.picoseconds           = value.d_nsec % (1000 * 1000) * 1000;
    d_value.datetime.parts       |= DatetimeParts::FRACSECONDS;
}

inline
void Datetime::setFractionOfSecond(Picoseconds value)
{
    d_value.datetime.milliSeconds
        = static_cast&lt;blpapi_UInt16_t&gt;(value.d_psec / 1000 / 1000 / 1000);
    d_value.picoseconds           = value.d_psec % (1000 * 1000 * 1000);
    d_value.datetime.parts       |= DatetimeParts::FRACSECONDS;
}

inline
blpapi_Datetime_t&amp; Datetime::rawValue()
{
    return d_value.datetime;
}

inline
blpapi_HighPrecisionDatetime_t&amp; Datetime::rawHighPrecisionValue()
{
    return d_value;
}

inline
bool Datetime::hasParts(unsigned parts) const
{
    return parts == (d_value.datetime.parts &amp; parts);
}

inline
unsigned Datetime::parts() const
{
    return d_value.datetime.parts;
}

inline
unsigned Datetime::year() const
{
    return d_value.datetime.year;
}

inline
unsigned Datetime::month() const
{
    return d_value.datetime.month;
}

inline
unsigned Datetime::day() const
{
    return d_value.datetime.day;
}

inline
unsigned Datetime::hours() const
{
    return d_value.datetime.hours;
}

inline
unsigned Datetime::minutes() const
{
    return d_value.datetime.minutes;
}

inline
unsigned Datetime::seconds() const
{
    return d_value.datetime.seconds;
}

inline
unsigned Datetime::milliSeconds() const
{
    return d_value.datetime.milliSeconds;
}

inline
unsigned Datetime::milliseconds() const
{
    return d_value.datetime.milliSeconds;
}

inline
unsigned Datetime::microseconds() const
{
    return   d_value.datetime.milliSeconds * 1000
           + d_value.picoseconds / 1000 / 1000;
}

inline
unsigned Datetime::nanoseconds() const
{
    return   d_value.datetime.milliSeconds * 1000 * 1000
           + d_value.picoseconds / 1000;
}

inline
unsigned long long Datetime::picoseconds() const
{
    return   d_value.datetime.milliSeconds * 1000LL * 1000 * 1000
           + d_value.picoseconds;
}

inline
short Datetime::offset() const
{
    return d_value.datetime.offset;
}

inline
const blpapi_Datetime_t&amp; Datetime::rawValue() const
{
    return d_value.datetime;
}

inline
const blpapi_HighPrecisionDatetime_t&amp; Datetime::rawHighPrecisionValue() const
{
    return d_value;
}

inline
bool Datetime::isValid() const
{
    if ( (hasParts(DatetimeParts::YEAR)
          || hasParts(DatetimeParts::MONTH)
          || hasParts(DatetimeParts::DAY) )
         &amp;&amp; !isValidDate(year(), month(), day()) ) {
        return false;
    }
    if ( (hasParts(DatetimeParts::HOURS)
          || hasParts(DatetimeParts::MINUTES)
          || hasParts(DatetimeParts::SECONDS)
          || hasParts(DatetimeParts::MILLISECONDS))
         &amp;&amp; !isValidTime(hours(), minutes(), seconds(), milliSeconds()) ) {
        return false;
    }
    if (   hasParts(DatetimeParts::FRACSECONDS)
        &amp;&amp; (picoseconds() &gt;= 1000LL * 1000 * 1000 * 1000)) {
        return false;
    }
    return true;
}

inline
std::ostream&amp; Datetime::print(std::ostream&amp; stream,
                              int           level,
                              int           spacesPerLevel) const
{
    BLPAPI_CALL_HIGHPRECISIONDATETIME_PRINT(
            &amp;d_value, OstreamWriter, &amp;stream, level, spacesPerLevel);
    return stream;
}

inline
bool operator==(const Datetime&amp; lhs, const Datetime&amp; rhs)
{
    if (lhs.parts() == rhs.parts()) {
        return (BLPAPI_CALL_HIGHPRECISIONDATETIME_COMPARE(
                                                  &amp;lhs.rawHighPrecisionValue(),
                                                  &amp;rhs.rawHighPrecisionValue())
                == 0);
    }
    return false;
}


inline
bool operator!=(const Datetime&amp; lhs, const Datetime&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bool operator&lt;(const Datetime&amp; lhs, const Datetime&amp; rhs)
{
    return (BLPAPI_CALL_HIGHPRECISIONDATETIME_COMPARE(
                                              &amp;lhs.rawHighPrecisionValue(),
                                              &amp;rhs.rawHighPrecisionValue())
            &lt; 0);
}

inline
bool operator&lt;=(const Datetime&amp; lhs, const Datetime&amp; rhs)
{
    return !(rhs &lt; lhs);
}

inline
bool operator&gt;(const Datetime&amp; lhs, const Datetime&amp; rhs)
{
    return rhs &lt; lhs;
}

inline
bool operator&gt;=(const Datetime&amp; lhs, const Datetime&amp; rhs)
{
    return !(lhs &lt; rhs);
}

inline
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Datetime&amp; datetime)
{
    return datetime.print(stream, 0, -1);
}

                            // ------------------
                            // class DatetimeUtil
                            // ------------------

inline
Datetime DatetimeUtil::fromTimePoint(const TimePoint&amp; timePoint,
                                     Datetime::Offset offset)
{
    blpapi_HighPrecisionDatetime_t highPrecisionDatetime;
    BLPAPI_CALL_HIGHPRECISIONDATETIME_FROMTIMEPOINT(
                      &amp;highPrecisionDatetime,
                      &amp;timePoint,
                      offset.d_minutesAheadOfUTC);
    return Datetime(highPrecisionDatetime);
}

}  // close namespace blpapi
}  // close namespace BloombergLP

#endif // #ifdef __cplusplus

#endif // #ifndef INCLUDED_BLPAPI_DATETIME
</pre>
</body>
</html>
